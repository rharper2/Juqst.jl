var documenterSearchIndex = {"docs":
[{"location":"probability-algs/#Probability-Distribution-Commands","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":"","category":"section"},{"location":"probability-algs/#Reading-in-and-fitting","page":"Probability Distribution Commands","title":"Reading in and fitting","text":"","category":"section"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":" readInCSVFile","category":"page"},{"location":"probability-algs/#Juqst.readInCSVFile","page":"Probability Distribution Commands","title":"Juqst.readInCSVFile","text":"readInCSVFile(filename)\n\nArguments\n\n`Filename`: full name of a csv delimited Filename\n\nFile Format\n\nAssumes that each sequence appears on a new line and each line has the same number of entries. Assumes that it is a raw count for each of the possible measurement outcomes. Note it is important to know the order of the outcomes (this is significant). Although this can be overriden, it is a assumed that they are stored as:\n\n    00000000\n    00000001\n    00000010\n    00000011\n\n    ...\n    11111110\n    11111111\n\n\ni.e. lsb to the right.\n\nReturns a full rows x col matrix depending on the number of entries of the file. for a 16 qubit machine, where the data was taken over 6 sequences we will return a 6x655536 array of Ints.\n\n\n\n\n\n","category":"function"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":"transformToFidelity","category":"page"},{"location":"probability-algs/#Juqst.transformToFidelity","page":"Probability Distribution Commands","title":"Juqst.transformToFidelity","text":"transformToFidelity(data)\n\nArguments:\n\n`Data`, as returned by readInCSVFile - see help for that function.\n\nReturns:\n\nThe Hadamard transformed fidelities for each sequence as a list of lists.\n\n\n\n\n\n","category":"function"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":"fitTheFidelities","category":"page"},{"location":"probability-algs/#Juqst.fitTheFidelities","page":"Probability Distribution Commands","title":"Juqst.fitTheFidelities","text":"fitTheFidelties(lengths, data; no =0)\n\nArguments\n\nlengths: Array{Int64,1}, e.g. collect(1:2:24) - the length at which each of the above sets of data was gathered.\n\ndata: Array{Array{Float64,1},1}, this is a list of observed probabilities at different sequences.\n\nno: printed with the warning message if we fail to fit. Allowing identification of problem in \"batch\" fits.\n\nTake the data, transform it  and see if we can fit it to an exponential decay. This proves problematic where the data is a bit sparse, as the decays can be all over the place. In general it is extremely helpful to have good 'low' gate sequence as that helps to anchor the fits. If we have an extremely high decay rate, the intercept parameter is difficult to find.\n\nHere we check for convergence, and warn if it doesn't converge.\n\nThis enforces a cut-off to the data used for the fit. Specifically it gets rid of the 'tail' of data.\n\nReturns\n\nthree things:\n\nthe fitting parameters, in the form [A,p], where A is the y-axis intercept and p is the decay probability.\nthe length of the sequence that was used for each parameter.\nthe indices of those that still failed to converge.\n\nTypical usage\n\n    params,_ = fitTheFidelities(collect(1:2:22),transformToFidelity(data))\n\n\n\n\n\n","category":"function"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":"convertAndProject","category":"page"},{"location":"probability-algs/#Juqst.convertAndProject","page":"Probability Distribution Commands","title":"Juqst.convertAndProject","text":"ConvertAndProject(params)\n\nArguments\n\nparams: parameters that come from the fittingTheFidelities method (list of A and p)\n\nConvert and project the fitted fidelities, to rerieve the 'p's representing the joint probabilities.\n\nReturns:\n\nthe projected probability distribuion.\n\n\n\n\n\n","category":"function"},{"location":"probability-algs/#Projecting-and-marginalising","page":"Probability Distribution Commands","title":"Projecting and marginalising","text":"","category":"section"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":"projectSimplex","category":"page"},{"location":"probability-algs/#Juqst.projectSimplex","page":"Probability Distribution Commands","title":"Juqst.projectSimplex","text":"projectSimplex(probs)\n\nArguments\n\nprobs: a probabiliity distribution, that isn't quite\n\nTakes the proffered probability distribution and projects it onto the closest probability distribution (where they are all >=0). Uses an algorithm similar to [Projection onto the probability simplex: An efficient algorithm with a simple proof, and an application)[https://arxiv.org/abs/1309.1541]\n\nReturns:\n\nthe projected probability distrubtion.\n\n\n\n\n\n","category":"function"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":"marginalise","category":"page"},{"location":"probability-algs/#Juqst.marginalise","page":"Probability Distribution Commands","title":"Juqst.marginalise","text":"marginalise(q,pps)\n\nArguments\n\nq the qubits you want to marginalise to, expressed as a list e.g. [1,2] marginalise away everything else    pps the probability distribution you want.\n\nExample    marginalise([1,3,5],pps)    returns the joint probability distribution of 1,3 and 5 with all other qubits marginalised out.\n\nReturns\n\nthe marginalised joint probability distribution. You may need to vec this.\n\n\n\n\n\n","category":"function"},{"location":"probability-algs/#Measuring-and-metrics","page":"Probability Distribution Commands","title":"Measuring and metrics","text":"","category":"section"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":"covarianceMatrix","category":"page"},{"location":"probability-algs/#Juqst.covarianceMatrix","page":"Probability Distribution Commands","title":"Juqst.covarianceMatrix","text":"covarianceMatrix(p)\n\nArguments\n\np a probability vector\n\nDiscussion\n\nComputes the covariance matrix between the 0/1 random variables representing no error / error.\nIf x is a column vector of bits representing an error pattern, then we can compute the matrix\nExpect_p[(x-μ) (x-μ)^T]\nwhere μ = Expect_p[x].\n\nIf we set reverse to true, then we reverse the digits.\nThe way IBM stores its digits we wouldn't normally want to reverse them, but in general\nthis might not be true\n\nReturns\n\nthe matrix Expect_p[(x-μ) (x-μ)^T]\n\n\n\n\n\n","category":"function"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":"correlationMatrix","category":"page"},{"location":"probability-algs/#Juqst.correlationMatrix","page":"Probability Distribution Commands","title":"Juqst.correlationMatrix","text":"correlationMatrix(p)\n\nCorrelation\n\nComputes the covariance matrix $\\Sigma$ and then let:\n$D = \\sqrt{diag{\\Sigma}$\n\nReturn $D^{-1}\\Sigma D^{-1}$\nSee also See also: [`covarianceMatrix`](@ref)\n\n\n\n\n\n","category":"function"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":"mutualInformation(p1,p2,p)","category":"page"},{"location":"probability-algs/#Juqst.mutualInformation-Tuple{Any, Any, Any}","page":"Probability Distribution Commands","title":"Juqst.mutualInformation","text":"mutualInformation(p1,p2,p)\n\nArguments\n\np1 a qubit position    p2 a qubit position    p a global probability distribution.\n\nReutrns\n\nthe mutualInformation between probabilities at p1, p2 given probability distribution p.\n\nComment\n\nMakes use of the marginalise function to marginalise over probabilities\n\n$MI(p1,p2) =\\sum\\limit_{x\\in p1,y\\in p2}\\left[p(x,y)\\log{\\frac{p(x,y)}{p(x),p(y)})\\right]$\n\n\nSome gotchas:\n    I return -1 if p1==p2 , this allows an identification of the qubit where I loop.\n    if p(x,y) is 0, p(x) or p(y) is 0 then this is defined as a 'zero' part of the sum - even though the log is undefined.\n\n\n\n\n\n","category":"method"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":" relativeEntropy(P,Q)","category":"page"},{"location":"probability-algs/#Juqst.relativeEntropy-Tuple{Any, Any}","page":"Probability Distribution Commands","title":"Juqst.relativeEntropy","text":"relativeEntropy(P, Q)\n\nCalculates the relative entropy between two joint probability distributions.\nD(P||Q) = Sum p_j*log(p_j/q_j)\n\nUndefined if any of the q_js are zero, unless the corresponding p_j is zero.\n\n\n\n\n\n","category":"method"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":"JSD(dist1,dist2)","category":"page"},{"location":"probability-algs/#Juqst.JSD-Tuple{Any, Any}","page":"Probability Distribution Commands","title":"Juqst.JSD","text":"JSD(dist1,dist2)\n\nArguments\n\ndist1, probability distribuion\ndist2, probability distribution\n\nDiscussion\n\ncalcluates the Jensen-Shannon Divergence between the two distributions. This is symmetric and well defined, even if the probabilities are not in each other's support. The square root is a metric.\n\nJSD(PQ) = frac12D(PM)+frac12D(QM), where\n\nM =frac12(P+Q)\n\nReturns JSD(PQ)\n\n\n\n\n\n","category":"method"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":"conditionalMutualInfo(X,Y,Z,p)","category":"page"},{"location":"probability-algs/#Juqst.conditionalMutualInfo-NTuple{4, Any}","page":"Probability Distribution Commands","title":"Juqst.conditionalMutualInfo","text":"conditionalMutualInfo     Pass in vectors of qubits for X Y and Z and the distribution to analyse.\n\nDiscussion\n\nGives the conditional mutual information for the qubits\nsupplied in X,Y and Z where we want I(XY|Z)\n\n$I(XY|Z) = \\Sum( P(x,y,z)\\log(2, P(Z)P(X,Y,Z)/P(X,Z)P(Y,Z) )$\n\nReturns\n\n$I(XY|Z)$\n\n\n\n\n\n","category":"method"},{"location":"probability-algs/#Gibbs-Random-Fields","page":"Probability Distribution Commands","title":"Gibbs Random Fields","text":"","category":"section"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":"gibbsRandomField","category":"page"},{"location":"probability-algs/#Juqst.gibbsRandomField","page":"Probability Distribution Commands","title":"Juqst.gibbsRandomField","text":"gibbsRandomField(pps,constraints)\n\nArguments\n\npps: Array{Float64,1} For example the output of convertAndProject\nconstraints: Array{Int64,1}: The division of the gibbs field. See below for example.\nTakes a joint probability and the gibbs variable constraints and returns a vector of reduced probability distributions.   For example the constraints might be [[1,2,3,4],[3,4,5,6],[5,6,7,8]] over a field of 8 qubits   This would return an array of 3 ϕ's each 16 long (2^4), from which the joint probability can be extracted on the assumption   That, say, qubits 1,2 are independent of qubits 5-8.   Note: the assumption inbuilt here is that the constraints end and start with qubits in common e.g. [1,2,->3,4],[3,4<-,5,6]\n\nNote the other version of is one gibbsRandomField, where the constraints are constraints::Array{Array{Array{Any,1},1},1} is probably (now) preferred - there you can specify the constraints more generally. In particular as tuples of qubits and the qubits they are conditioned on.\n\nReturns\n\nϕ as a series of factors, depending on the constraints.\n\n\n\n\n\ngibbsRandomField(pps,gen_constraints)\n\nArguments\n\npps: Array{Float64,1} For example the output of convertAndProject\nconstraints: Array{Array{Array{Any,1},1},1}: The division of the gibbs field. See below for example.\nTakes a joint probability and the variable constraints that are conditioned and returns a vector of reduced probability distributions.   It is up to the user to make sure that the factorization is complete and makes sense.   For example the constraints might be [[(1,2),(3,4)],[(3,),(4,5,6)],[(4,5,6,7,8),()]] over a field of 8 qubits   This would return an array of 3 ϕ's the first 16 long (2^4), the second 2^4 long and the third 2^5 long from which the joint probability can be extracted on the assumption   That, say, qubits 1,2 are independent of qubits 5-8.\n\nReturns\n\nϕ as a series of factors, depending on the constraints.\n\n\n\n\n\n","category":"function"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":"gibbsRandomField(pps,constraints::Array{Array{Array{Any,1},1},1})","category":"page"},{"location":"probability-algs/#Juqst.gibbsRandomField-Tuple{Any, Vector{Vector{Vector{Any}}}}","page":"Probability Distribution Commands","title":"Juqst.gibbsRandomField","text":"gibbsRandomField(pps,gen_constraints)\n\nArguments\n\npps: Array{Float64,1} For example the output of convertAndProject\nconstraints: Array{Array{Array{Any,1},1},1}: The division of the gibbs field. See below for example.\nTakes a joint probability and the variable constraints that are conditioned and returns a vector of reduced probability distributions.   It is up to the user to make sure that the factorization is complete and makes sense.   For example the constraints might be [[(1,2),(3,4)],[(3,),(4,5,6)],[(4,5,6,7,8),()]] over a field of 8 qubits   This would return an array of 3 ϕ's the first 16 long (2^4), the second 2^4 long and the third 2^5 long from which the joint probability can be extracted on the assumption   That, say, qubits 1,2 are independent of qubits 5-8.\n\nReturns\n\nϕ as a series of factors, depending on the constraints.\n\n\n\n\n\n","category":"method"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":"getGrainedP(ϕ,tomatch,graining)","category":"page"},{"location":"probability-algs/#Juqst.getGrainedP-Tuple{Any, Any, Any}","page":"Probability Distribution Commands","title":"Juqst.getGrainedP","text":"getGrainedP(ϕ,tomatch,graining)\n\nArguments\n\nϕ: the factor graph (possibly obtained through gibbsRandomField)\ntomatch: the bit pattern we want\ngraining: the split for the factor graph.\n\nDescription\n\nFor instance say we want all bits zero apart from qubit 3 (which = 1)    Then for ϕ[1], which represents bits [2,1,3,6] - we need the entry corresponding to decimal equiv of reverse(0,0,1,0)    plus one, because 0 0 0 0 = first entry i.e. index 1.    We will have length(ϕ) of these entries, this gives us the perVecIndex.    Then we just read it out for ϕ, with a map, using foldl to multiply them for us.\n\nExample use\n\n   generalisedConstraints =[\n                        [[1,],[2,14]],\n                        [[2,14],[13,3]],\n                        [[13,3],[4,12]],\n                        [[4,12],[5,11]],\n                        [[5,11],[6,10]],\n                        [[6,10],[7,9]],\n                        [[7,9,8],[]]]\n    ϕ=Marginal.gibbsRandomField(singlePps,generalisedConstraints)\n    reconstructed = [Marginal.getGrainedP(ϕ,tomatch,[vcat(x[1],x[2]) for x in generalisedConstraints]) for tomatch =0:(2^14-1)]\n\n\nTakes a global probability distribution, uses it to fill in the factor graph variables spedified in generalisedConstraints\nand the reconstructs the probability distribution as given by the factor graph.\n\nReturns:\n\n for the given tomatch bitpattern the extracted probability.\n\n\n\n\n\n","category":"method"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":"reconstruct(dist,constraints)","category":"page"},{"location":"probability-algs/#Juqst.reconstruct-Tuple{Any, Any}","page":"Probability Distribution Commands","title":"Juqst.reconstruct","text":"Given a distribution and a set of constraints.\nReturn the reconstruction of a distribution parameterized by the constraints.\n\n\n\n\n\n","category":"method"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":"reconstructedJS(distribution,constraints)","category":"page"},{"location":"probability-algs/#Juqst.reconstructedJS-Tuple{Any, Any}","page":"Probability Distribution Commands","title":"Juqst.reconstructedJS","text":"reconstructedJS\n\nArguments\n\ndistribution: a probability distribution\nconstraints: a set of constraints (see first form of gibbsRandomField)\n\nDiscusion\n\nGiven a distribution and a set of constraints.\nReconstruct the distribution using the constraints.\n\nReturn\n\nThe JSD of the reconstructed distribution and the original distribution.\n\n\n\n\n\n","category":"method"},{"location":"probability-algs/","page":"Probability Distribution Commands","title":"Probability Distribution Commands","text":"marginaliseFromRawData","category":"page"},{"location":"probability-algs/#Juqst.marginaliseFromRawData","page":"Probability Distribution Commands","title":"Juqst.marginaliseFromRawData","text":"marginaliseFromRawData\n\nrawData - all of the observations ie. an array of 1..|lengths] each being a $2^n$ vector.\nconstraints - currently a list of constraints in the same from as [`gibbsRandomField(pps,constraints)`][@ref]\nlengths - the lengths the data sets were taken at\n\nTakes in the raw observations, for each of the lengths specified in length.\nExtracts the joint probabilities needed from constraints.\nMarginalises the observations, transforms, fits, transforms and fills in the joint probabilities.\nReturns the completed gibbs factors.\n\nNote if your $2^n$  vectors are too big, simply re-write to pass in the actual observations and work out the marginalised observations as you scan through them,\npotentially sparse arrays will help (although not sure if marginalise will work)\n\n\n\n\n\n","category":"function"},{"location":"chp/#CHP/Tableau-Commands","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":"","category":"section"},{"location":"chp/#Creating-and-manipulating","page":"CHP/Tableau Commands","title":"Creating and manipulating","text":"","category":"section"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" Tableau(n::Integer)","category":"page"},{"location":"chp/#Juqst.Tableau-Tuple{Integer}","page":"CHP/Tableau Commands","title":"Juqst.Tableau","text":"Tableau(n::Integer)\n\nsets up and returns the a CHP Tableau for n qubits.\n\nThis is based on the formalism given by:  Improved Simulation of Stabilizer Circuits,  Scott Aaronson and Daniel Gottesman,  arXiv:quant-ph/0406196v5\n\nThe initial tableau represents a |00...0rangle ket in the stabiliser state  This stabilises with \"Z\" and anti-stabilises with \"X\"  So the tableau starts off with an Identity in the 'anti commute' top half in the X section   and identity in the commuting (bottom) half in the Z section.\n\nFor the purposes of this port, the tableau is exactly replicated as per the paper  i.e. the \"state\" (Tableau.state) is an Int32 array (used as a bit array)  containing the following information.\n\n x11   .....  x1n | z11   ...      z1n | r1\n  .    \\       .  |  .    \\          . |  .\n  .     \\      .  |  .     \\         . |  .     Destabilisers\n  .      \\     .  |  .      \\        . |  .\n xn1      \\   xnn | zn1      \\      znn| rn\n ______________________________________________\n x(n+1)1. x(n+1)n | z(n+1) ... z(n+1)n | r(n+1)\n  .    \\       .  |  .      \\        . |  .\n  .     \\      .  |  .       \\       . |  .     Stabilisers\n  .      \\     .  |  .        \\      . |  .\n x(2n)1   \\x(2n)n | z(2n)1     \\ z(2n)n| r(2n)\n\nSet Tableau.showRaw to true to see the underlying state as a matrix.\n\nSee also: cnot, hadamard, phase, measure, X, Z\n\nRelated: cliffordToTableau\n\n\n\n\n\n","category":"method"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" hadamard","category":"page"},{"location":"chp/#Juqst.hadamard","page":"CHP/Tableau Commands","title":"Juqst.hadamard","text":"hadamard(t::Tableau,qubit::Integer,showOutput::Bool=false)\n\nPerforms a hadamard gate on the specified qubit of the tableau.\n\nSee also: cnot, phase, measure, X, Z\n\n\n\n\n\nhadamard(t::Tableau,qubits::Integer...;showOutput::Bool = false)\n\nPeforms hadamards on each of the qubits supplied.\n\nExamples\n\njulia> hadamard(t,2,3,1)\n\nSee also: cnot phase, measure, X, Z\n\n\n\n\n\n","category":"function"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" phase","category":"page"},{"location":"chp/#Juqst.phase","page":"CHP/Tableau Commands","title":"Juqst.phase","text":"phase(t::Tableau,qubit::Integer,showOutput::Bool=false)\n\nPerforms a phase gate on the specified qubit of the tableau.\n\nSee also: cnot, hadamard, measure, X, Z\n\n\n\n\n\nphase(t::Tableau,qubits::Integer...;showOutput::Bool = false)\n\nPeforms phase on each of the qubits supplied.\n\nExamples\n\njulia> phase(t,2,3,1)\n\nSee also: cnot hadamard, measure, X, Z\n\n\n\n\n\n","category":"function"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" cnot","category":"page"},{"location":"chp/#Juqst.cnot","page":"CHP/Tableau Commands","title":"Juqst.cnot","text":"cnot(t::Tableau,control::Integer,target::Integer,showOutput=false)\n\nPerforms a CNOT (controlled not) on the tableau, with the specified qubits as control and target.\n\nIf showOutput is passed as true the state of the tableau subsequent to the cnot is printed.\n\nSee also: hadamard, phase, measure, X, Z\n\n\n\n\n\n","category":"function"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" X","category":"page"},{"location":"chp/#Juqst.X","page":"CHP/Tableau Commands","title":"Juqst.X","text":"X(t::Tableau,qubit::Integer,showOutput::Bool=false)\n\nConvenience function to perform an 'X' gate on the tableau. Performs hadamard, two phase gates and a hadamard.\n\nSee also: cnot, hadamard, measure, Z, phase\n\n\n\n\n\nX(t::Tableau,qubits::Integer...;showOutput::Bool = false)\n\nConvenience function to perform an 'X' gate on the tableau on each of the qubits supplied. Performs the gate by doing a hadamard, two phase gates and a hadamard on each of the qubits.\n\nExamples\n\njulia> X(t,2,3,1)\n\nSee also: cnot hadamard, measure, phase, Z\n\n\n\n\n\n","category":"function"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" Z","category":"page"},{"location":"chp/#Juqst.Z","page":"CHP/Tableau Commands","title":"Juqst.Z","text":"Z(t::Tableau,qubit::Integer,showOutput::Bool=false)\n\nConvenience function to perform a 'Z' gate on the tableau. Performs two phase gates.\n\nSee also: cnot, hadamard, measure, X, phase\n\n\n\n\n\nZ(t::Tableau,qubits::Integer...;showOutput::Bool = false)\n\nConvenience function to perform a 'Z' gate on the tableau on each of the qubits supplied. Performs the gate by doing two phase gates.\n\nExamples\n\njulia> Z(t,2,3,1)\n\nSee also: cnot hadamard, measure, X, Z\n\n\n\n\n\n","category":"function"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" measure","category":"page"},{"location":"chp/#Juqst.measure","page":"CHP/Tableau Commands","title":"Juqst.measure","text":"measure(t::Tableau,qubit::Integer)\n\nPerforms a measurement on the supplied qubit. If the Tableau is not in a Z eigenstate, it will (pseudo) randomly choose the result and collapse the Tableau approriately.\n\n\n\n\n\nmeasure(t::Tableau,qubits::Integer...;showOutput = false)\n\nPerforms a measurement on the supplied qubits. Results are reproted in a dictionary of outcomes.\n\nExamples\n\njulia> using Main.CHP\n\njulia> t = Tableau(4)\n\n+XIII\n+IXII\n+IIXI\n+IIIX\n-----\n+ZIII\n+IZII\n+IIZI\n+IIIZ\n\n\njulia> measure(t,1,2)\nDict{Any,Any}(2=>0,1=>0)\njulia>\n\n\n\n\n\nHelper function   Pass in the state, the noise (superOperator) and the measurements - use allZs to generate)   returns the mapped function.\n\n\n\n\n\n","category":"function"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" kets","category":"page"},{"location":"chp/#Juqst.kets","page":"CHP/Tableau Commands","title":"Juqst.kets","text":"kets(tableau::Tableau)\n\nreturns a string showing the kets of the state stabilised by the tableau.\n\n\n\n\n\n","category":"function"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" initialise","category":"page"},{"location":"chp/#Juqst.initialise","page":"CHP/Tableau Commands","title":"Juqst.initialise","text":"initialise(t::Tableau)\n\nInitialises the Tableau, setting it support the |000000> state. However, unlike reinitialse it does not change the commands associated with the Tableau.\n\nSee also: reinitialise\n\n\n\n\n\n","category":"function"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" reinitialise","category":"page"},{"location":"chp/#Juqst.reinitialise","page":"CHP/Tableau Commands","title":"Juqst.reinitialise","text":"reinitialise(t::Tableau)\n\nReinitialise the Tableau, setting it support the |000000> state. Resets all commands associated with the Tableau.\n\nSee also: initialise\n\n\n\n\n\n","category":"function"},{"location":"chp/#Tableaus-and-Cliffords","page":"CHP/Tableau Commands","title":"Tableaus and Cliffords","text":"","category":"section"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" cliffordToTableau","category":"page"},{"location":"chp/#Juqst.cliffordToTableau","page":"CHP/Tableau Commands","title":"Juqst.cliffordToTableau","text":"cliffordToTableau(qubits,clifford,signs)\n\nConverts an integer into a Clifford. You need to specify the number of qubits in the tableau, the clifford number and the bit signs corresponding to the rows of the Tableau. The commands used to create the Clifford can be found in Tableau.commands and Tableau.executeCommands.? It is fine to specify numbers that are too large (they wrap), but the helper functions\n\ngetNumberOfSymplecticCliffords(n::BigInt)::BigInt\ngetNumberOfBitStringsCliffords(n)\n\nWill show how many cliffords there are for a certain number of qubits (Warning this is a very large number for n > 2)\n\n\n\n\n\n","category":"function"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" tableauToClifford","category":"page"},{"location":"chp/#Juqst.tableauToClifford","page":"CHP/Tableau Commands","title":"Juqst.tableauToClifford","text":"tableauToClifford(t::Tableau)\n\nReturns the 'symplectic' number that corresponds to the clifford embedded in the Tableau. Note that this is modulo the bit signs. I.e. the tableaus corresponding to e.g. cliffordToTableau(1,3,3) and cliffordToTableau(1,3,4) will both return 3.\n\n\n\n\n\n","category":"function"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" decomposeState","category":"page"},{"location":"chp/#Juqst.decomposeState","page":"CHP/Tableau Commands","title":"Juqst.decomposeState","text":"decomposeState(tableau::Tableau,rationalise=true)\n\nDecomposes the state stabilised by the Tableau using the Aaronsen/Gottesman method\n\nThat is it will decompose the \"arbitrary\" state into a series of CHP (cnot, hadamard and phase) gates. This is unlikely to be the most concise decomposition. Unless rationalise is set to false there will be some naive trimming of gates, basically self eliminating gates (e.g. 4 phase gates) are removed. The commands (and the execCommands) in the tableau are wiped and recreated. Following the decomposition the state is re-created using the new commands.\n\n\n\n\n\n","category":"function"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" getNumberOfCliffords","category":"page"},{"location":"chp/#Juqst.getNumberOfCliffords","page":"CHP/Tableau Commands","title":"Juqst.getNumberOfCliffords","text":"getNumberOfCliffords(n::Integer)::BigInt\n\nreturns the number of Cliffords for n qubits.\n\n\n\n\n\n","category":"function"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" getNumberOfSymplecticCliffords","category":"page"},{"location":"chp/#Juqst.getNumberOfSymplecticCliffords","page":"CHP/Tableau Commands","title":"Juqst.getNumberOfSymplecticCliffords","text":"getNumberOfSymplecticCliffords(n::Integer)::BigInt\n\nreturns the number of Cliffords for n qubits, modulo the signs on each row of the tableau. Note\n\ngetNumberOfCliffords(n) == getNumberOfSymplecticCliffords(n)*getNumerOfBitStringsCliffords(n)\n\n\n\n\n\n","category":"function"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" getNumberOfBitStringsCliffords","category":"page"},{"location":"chp/#Juqst.getNumberOfBitStringsCliffords","page":"CHP/Tableau Commands","title":"Juqst.getNumberOfBitStringsCliffords","text":"getNumberOfBitStringsCliffords(n)\n\nreturns the number of bitstrings representing a +/- on each row for the Tableau. Note:\n\ngetNumberOfCliffords(n) == getNumberOfSymplecticCliffords(n)*getNumerOfBitStringsCliffords(n)\n\n\n\n\n\n","category":"function"},{"location":"chp/#Generating-Clifford-matrices","page":"CHP/Tableau Commands","title":"Generating Clifford matrices","text":"","category":"section"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" generateRawCliffords","category":"page"},{"location":"chp/#Juqst.generateRawCliffords","page":"CHP/Tableau Commands","title":"Juqst.generateRawCliffords","text":"generateRawCliffords(;phaseGate=[1 0;0 im],hadmardGate=1/sqrt(2)*[1 1;1 -1])::Array{Complex{Float64},2}[]\n\nreturns the single qubit cliffords, generated using the passed in  phase and hadamard gates (perfect gates default)\n\n\n\n\n\n","category":"function"},{"location":"chp/","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" makeFromCommand","category":"page"},{"location":"chp/#Juqst.makeFromCommand","page":"CHP/Tableau Commands","title":"Juqst.makeFromCommand","text":"makeFromCommand(command)\n\nTakes the commands in a Tableau and uses them to build a matrix representing the Tableau (in the computational basis)\nUses the original initialise command to determine the size of the system.\nNote: for many qubits this gets quite big (scales as $2^n$)\n\n\n\n\n\nmakeFromCommand(t::Tableau)\n\nUses the commands stored in a Tableau and uses them to build a matrix representing the Tableau (in the computational basis)\nUses the original initialise command to determine the size of the system.\nNote: for many qubits this gets quite big (scales as $2^n$)\n\n\n\n\n\n","category":"function"},{"location":"channels/#Random-Channels","page":"Random Channels","title":"Random Channels","text":"","category":"section"},{"location":"channels/#Measurements","page":"Random Channels","title":"Measurements","text":"","category":"section"},{"location":"channels/","page":"Random Channels","title":"Random Channels","text":" fidelity","category":"page"},{"location":"channels/#Juqst.fidelity","page":"Random Channels","title":"Juqst.fidelity","text":"returns the fidelity of the channel (in PauliLiouville basis)\n\n\n\n\n\n","category":"function"},{"location":"channels/","page":"Random Channels","title":"Random Channels","text":" unitarity","category":"page"},{"location":"channels/#Juqst.unitarity","page":"Random Channels","title":"Juqst.unitarity","text":"returns the unitarity of the channel (PauliLiouville basis)\n\n\n\n\n\n","category":"function"},{"location":"channels/","page":"Random Channels","title":"Random Channels","text":" unitarityPercent","category":"page"},{"location":"channels/#Juqst.unitarityPercent","page":"Random Channels","title":"Juqst.unitarityPercent","text":"A given fidelity has a minimum unitarity that it can have\n(so perfect fidelity = 1 = unitarity)\nThis shows as a percentage how much the unitarity of the channel\nlies between the minimum and the maximum (always 1)\n\n\n\n\n\n","category":"function"},{"location":"channels/#Creation","page":"Random Channels","title":"Creation","text":"","category":"section"},{"location":"channels/","page":"Random Channels","title":"Random Channels","text":" genChannel","category":"page"},{"location":"channels/#Juqst.genChannel","page":"Random Channels","title":"Juqst.genChannel","text":"genChannel(r1,sm,sv,r2)\nRotate the sigma channel randomly to generate an arbitrary channel\nr1 represents a rotation. The elements of a vector of three normally distributed elements are multiplied by this and used as an XZX rotation. For high fidelity channels this will be small.\nsm, represents the diagonal channel. This is the mean. High fidelity channels will have this close to 1.\nsv, represents the variance in the diagonal channel.\nr2, like r1.\n\nFor example randomFidelityNoise is defined as   genChannel(0.06,0.998,0.04,0.06)\nwhereas the noisier randomMeasureNoise is       genChannel(0.05,0.98,0.15,0.05)\n\n\n\n\n\n","category":"function"},{"location":"channels/","page":"Random Channels","title":"Random Channels","text":" randomFidelityNoise","category":"page"},{"location":"channels/#Juqst.randomFidelityNoise","page":"Random Channels","title":"Juqst.randomFidelityNoise","text":"Helper function to generate typical, high fidelity channel.\n\n\n\n\n\n","category":"function"},{"location":"channels/","page":"Random Channels","title":"Random Channels","text":" randomPrepNoise","category":"page"},{"location":"channels/#Juqst.randomPrepNoise","page":"Random Channels","title":"Juqst.randomPrepNoise","text":"Helper function to generate typical, lower fidelity channel.\nI use it to simulate a state preparation channel.\n\n\n\n\n\n","category":"function"},{"location":"channels/","page":"Random Channels","title":"Random Channels","text":" randomMeasureNoise","category":"page"},{"location":"channels/#Juqst.randomMeasureNoise","page":"Random Channels","title":"Juqst.randomMeasureNoise","text":"Helper function to generate typical, lower fidelity channel.\nI typically use it to simulate measurement error.\n\n\n\n\n\n","category":"function"},{"location":"channels/","page":"Random Channels","title":"Random Channels","text":" genChannelMap","category":"page"},{"location":"channels/#Juqst.genChannelMap","page":"Random Channels","title":"Juqst.genChannelMap","text":"function genChannelMap(f)\nSimple helper function - designed to help generate a map of a specific fidelity (supplied parameter).\nJust generates random channels until you get one of the correct fidelity $\\pm 0.0001$.\nIn general though you would want to rewrite this to give genChannel\nparameters that will result in random channels that often bracket the desired fidelity\nMay take a long time if the parameters are far from the types of channels generated\nby randomFidelityNoise.\n\n\n\n\n\n","category":"function"},{"location":"#Juqst-Documentation","page":"Juqst Documentation","title":"Juqst Documentation","text":"","category":"section"},{"location":"","page":"Juqst Documentation","title":"Juqst Documentation","text":"Pages = [\"chp.md\", \"open-systems.md\",\"channels.md\",\"probability-algs.md\"]\nDepth = 2","category":"page"},{"location":"","page":"Juqst Documentation","title":"Juqst Documentation","text":"This is some software that brings together:","category":"page"},{"location":"","page":"Juqst Documentation","title":"Juqst Documentation","text":"a simulation of stabiliser circuits Aaronson/Gottesman arXiv:quant-ph/0406196\ncode to select an arbitrary Clifford group element Koenig/Smolin arXiv:quant-ph/1406.2170\ndecomposition an arbitrary clifford unitary into a quantum circuit consistiting of hadamard, phase and two-qubit cnot gates Aaronson/Gottesman arXiv:quant-ph/0406196\nconversion of the Tableau to a unitary matrix\na slightly modified version of Marcus da Silva's QuantumInfo.jl - updated with some minor modifications and additions.\nsome additional functionality to allow the creation of random quantum channels (for testing purposes).","category":"page"},{"location":"","page":"Juqst Documentation","title":"Juqst Documentation","text":"GitHub repo Juqst.jl","category":"page"},{"location":"open-systems/#Channel-Conversions","page":"Channel Conversions","title":"Channel Conversions","text":"","category":"section"},{"location":"open-systems/#Conversion","page":"Channel Conversions","title":"Conversion","text":"","category":"section"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" choi2liou","category":"page"},{"location":"open-systems/#Juqst.choi2liou","page":"Channel Conversions","title":"Juqst.choi2liou","text":"choi2liou\n\nTakes a superoperator in choi matrix form and returns the liouville superoperator (computational basis)\n\n\n\n\n\n","category":"function"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" choi2kraus","category":"page"},{"location":"open-systems/#Juqst.choi2kraus","page":"Channel Conversions","title":"Juqst.choi2kraus","text":"takes the choi matrix and returns the kraus operators.    This stays the same, save that we need to take into account dimensional factors.    Note slight negative eigenvalue (rounding can cause problems). Here I round to 15 digits.\n\n\n\n\n\n","category":"function"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" choiX2liou","category":"page"},{"location":"open-systems/#Juqst.choiX2liou","page":"Channel Conversions","title":"Juqst.choiX2liou","text":"takes the Chi matrix (Choi matrix in Pauli basis) and return the liouville superoperator, computaitonal basis\n\n\n\n\n\n","category":"function"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" choi2chi","category":"page"},{"location":"open-systems/#Juqst.choi2chi","page":"Channel Conversions","title":"Juqst.choi2chi","text":"Takes a choi matrix and returns the Chi Matrix    Note the basis here has changed from marcusps version,  The rightmost paulis are varying the quickest.   Also note the transpose ( .' ) - this makes it ROW stacking   So for instance   (0 -im//im 0) vectorises as (0 -im im 0) (unlike column used elsewhere where its (0 im -im 0))\n\n\n\n\n\n","category":"function"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" kraus2choi","category":"page"},{"location":"open-systems/#Juqst.kraus2choi","page":"Channel Conversions","title":"Juqst.kraus2choi","text":"Takes a vector of kraus operators and returns the choi matrix\n\n\n\n\n\n","category":"function"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" kraus2liou","category":"page"},{"location":"open-systems/#Juqst.kraus2liou","page":"Channel Conversions","title":"Juqst.kraus2liou","text":"Takes a vector of kraus operators (matrices) and    converts them to a liouville superoperator (computational basis)\n\n\n\n\n\n","category":"function"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":"liou2choi","category":"page"},{"location":"open-systems/#Juqst.liou2choi","page":"Channel Conversions","title":"Juqst.liou2choi","text":"liou2choi\n\nTake a liouville superoperator (computational basis) and return the choi matrix\n\n\n\n\n\n","category":"function"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" liou2choiX","category":"page"},{"location":"open-systems/#Juqst.liou2choiX","page":"Channel Conversions","title":"Juqst.liou2choiX","text":"takes a liouville superoperator (computational basis) and returns the Chi matrix   (basically the choi matrix in Pauli basis)\n\n\n\n\n\n","category":"function"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" liou2kraus","category":"page"},{"location":"open-systems/#Juqst.liou2kraus","page":"Channel Conversions","title":"Juqst.liou2kraus","text":"Takes a liouville superoperator (computational basis) and   returns a vector of the equivalen Krawu vectors\n\n\n\n\n\n","category":"function"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" liou2pauliliou","category":"page"},{"location":"open-systems/#Juqst.liou2pauliliou","page":"Channel Conversions","title":"Juqst.liou2pauliliou","text":"Converts a liouville superoperator in the computaional basis   to one in the pauli basis. Order of Paulis is I,X,Y and Z.\n\n\n\n\n\n","category":"function"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" pauliliou2liou","category":"page"},{"location":"open-systems/#Juqst.pauliliou2liou","page":"Channel Conversions","title":"Juqst.pauliliou2liou","text":"Converts a liouville superoperator in the Pauli basis   to one in the computational basis. Order of Paulis is I,X,Y and Z.\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#Manipulation","page":"Channel Conversions","title":"Manipulation","text":"","category":"section"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" makeSuper","category":"page"},{"location":"open-systems/#Juqst.makeSuper","page":"Channel Conversions","title":"Juqst.makeSuper","text":"function makeSuper(u)\n\nTakes an operator and turns into a superoperator. Pauli basis.\n\n\n\n\n\n","category":"function"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" Juqst.getSuperVec","category":"page"},{"location":"open-systems/#Juqst.getSuperVec","page":"Channel Conversions","title":"Juqst.getSuperVec","text":"pass in a density matrix, gives you the super vector that corresponds to it\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#Verification","page":"Channel Conversions","title":"Verification","text":"","category":"section"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" istp","category":"page"},{"location":"open-systems/#Juqst.istp","page":"Channel Conversions","title":"Juqst.istp","text":"istp(m;tol)\n\nReturns whether is trace perserving..   Assumes input is in liouville basis (not pauli-liouville - use pauliliou2liou)\n\n\n\n\n\n","category":"function"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" iscp","category":"page"},{"location":"open-systems/#Juqst.iscp","page":"Channel Conversions","title":"Juqst.iscp","text":"iscp(m;tol)\n\nReturns whether is completely positivel.   Assumes input is in liouville basis (not pauli-liouville - use pauliliou2liou)   Converts to choi and checks the eigenvalues.   – tweaked to increase eps slightly was getting a trivial false !cp right on the boundary.\n\n\n\n\n\n","category":"function"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" ischannel","category":"page"},{"location":"open-systems/#Juqst.ischannel","page":"Channel Conversions","title":"Juqst.ischannel","text":"ischannel(m;tol)\n\nReturns whether is the liouville superoperator is trace perserving and completely positive.   Assumes input is in liouville basis (not pauli-liouville - use pauliliou2liou)\n\n\n\n\n\n","category":"function"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" isunital","category":"page"},{"location":"open-systems/#Juqst.isunital","page":"Channel Conversions","title":"Juqst.isunital","text":"unital(m;tol)\n\nReturns whether is the liouville superoperator is unital.   Assumes input is in liouville basis (not pauli-liouville - use pauliliou2liou)\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#Helper","page":"Channel Conversions","title":"Helper","text":"","category":"section"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" Juqst.genLabels","category":"page"},{"location":"open-systems/#Juqst.genLabels","page":"Channel Conversions","title":"Juqst.genLabels","text":"Helper function for labeling graphs, pass in the qubits get the string of Is and Zs   e.g. with two you get [\"00\",\"01\",\"10\",\"11\"]\n\n\n\n\n\n","category":"function"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" Juqst.measure(s,measureNoise,allZs)","category":"page"},{"location":"open-systems/#Juqst.measure-Tuple{Any, Any, Any}","page":"Channel Conversions","title":"Juqst.measure","text":"Helper function   Pass in the state, the noise (superOperator) and the measurements - use allZs to generate)   returns the mapped function.\n\n\n\n\n\n","category":"method"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" Juqst.genArrows","category":"page"},{"location":"open-systems/#Juqst.genArrows","page":"Channel Conversions","title":"Juqst.genArrows","text":"Helper function (chart axis)   return all the ups and downs for a certain number of qubits as a list of strings\n\n\n\n\n\n","category":"function"},{"location":"open-systems/","page":"Channel Conversions","title":"Channel Conversions","text":" Juqst.genZs","category":"page"},{"location":"open-systems/#Juqst.genZs","page":"Channel Conversions","title":"Juqst.genZs","text":"returns an array of the 'measurement' operators that extract each of the z measurements   e.g. for two qubits will return the II, IZ, ZI and ZZ measurements\n\n\n\n\n\n","category":"function"}]
}
