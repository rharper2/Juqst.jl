var documenterSearchIndex = {"docs":
[{"location":"chp/#CHP/Tableau-Commands-1","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":"","category":"section"},{"location":"chp/#Creating-and-manipulating-1","page":"CHP/Tableau Commands","title":"Creating and manipulating","text":"","category":"section"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" Tableau(n::Integer)","category":"page"},{"location":"chp/#Juqst.Tableau-Tuple{Integer}","page":"CHP/Tableau Commands","title":"Juqst.Tableau","text":"Tableau(n::Integer)\n\nsets up and returns the a CHP Tableau for n qubits.\n\nThis is based on the formalism given by:  Improved Simulation of Stabilizer Circuits,  Scott Aaronson and Daniel Gottesman,  arXiv:quant-ph/0406196v5\n\nThe initial tableau represents a |00...0rangle ket in the stabiliser state  This stabilises with \"Z\" and anti-stabilises with \"X\"  So the tableau starts off with an Identity in the 'anti commute' top half in the X section   and identity in the commuting (bottom) half in the Z section.\n\nFor the purposes of this port, the tableau is exactly replicated as per the paper  i.e. the \"state\" (Tableau.state) is an Int32 array (used as a bit array)  containing the following information.\n\n x11   .....  x1n | z11   ...      z1n | r1\n  .    \\       .  |  .    \\          . |  .\n  .     \\      .  |  .     \\         . |  .     Destabilisers\n  .      \\     .  |  .      \\        . |  .\n xn1      \\   xnn | zn1      \\      znn| rn\n ______________________________________________\n x(n+1)1. x(n+1)n | z(n+1) ... z(n+1)n | r(n+1)\n  .    \\       .  |  .      \\        . |  .\n  .     \\      .  |  .       \\       . |  .     Stabilisers\n  .      \\     .  |  .        \\      . |  .\n x(2n)1   \\x(2n)n | z(2n)1     \\ z(2n)n| r(2n)\n\nSet Tableau.showRaw to true to see the underlying state as a matrix.\n\nSee also: cnot, hadamard, phase, measure, X, Z\n\nRelated: cliffordToTableau\n\n\n\n\n\n","category":"method"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" hadamard","category":"page"},{"location":"chp/#Juqst.hadamard","page":"CHP/Tableau Commands","title":"Juqst.hadamard","text":"hadamard(t::Tableau,qubit::Integer,showOutput::Bool=false)\n\nPerforms a hadamard gate on the specified qubit of the tableau.\n\nSee also: cnot, phase, measure, X, Z\n\n\n\n\n\nhadamard(t::Tableau,qubits::Integer...;showOutput::Bool = false)\n\nPeforms hadamards on each of the qubits supplied.\n\nExamples\n\njulia> hadamard(t,2,3,1)\n\nSee also: cnot phase, measure, X, Z\n\n\n\n\n\n","category":"function"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" phase","category":"page"},{"location":"chp/#Juqst.phase","page":"CHP/Tableau Commands","title":"Juqst.phase","text":"phase(t::Tableau,qubit::Integer,showOutput::Bool=false)\n\nPerforms a phase gate on the specified qubit of the tableau.\n\nSee also: cnot, hadamard, measure, X, Z\n\n\n\n\n\nphase(t::Tableau,qubits::Integer...;showOutput::Bool = false)\n\nPeforms phase on each of the qubits supplied.\n\nExamples\n\njulia> phase(t,2,3,1)\n\nSee also: cnot hadamard, measure, X, Z\n\n\n\n\n\n","category":"function"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" cnot","category":"page"},{"location":"chp/#Juqst.cnot","page":"CHP/Tableau Commands","title":"Juqst.cnot","text":"cnot(t::Tableau,control::Integer,target::Integer,showOutput=false)\n\nPerforms a CNOT (controlled not) on the tableau, with the specified qubits as control and target.\n\nIf showOutput is passed as true the state of the tableau subsequent to the cnot is printed.\n\nSee also: hadamard, phase, measure, X, Z\n\n\n\n\n\n","category":"function"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" X","category":"page"},{"location":"chp/#Juqst.X","page":"CHP/Tableau Commands","title":"Juqst.X","text":"X(t::Tableau,qubit::Integer,showOutput::Bool=false)\n\nConvenience function to perform an 'X' gate on the tableau. Performs hadamard, two phase gates and a hadamard.\n\nSee also: cnot, hadamard, measure, Z, phase\n\n\n\n\n\nX(t::Tableau,qubits::Integer...;showOutput::Bool = false)\n\nConvenience function to perform an 'X' gate on the tableau on each of the qubits supplied. Performs the gate by doing a hadamard, two phase gates and a hadamard on each of the qubits.\n\nExamples\n\njulia> X(t,2,3,1)\n\nSee also: cnot hadamard, measure, phase, Z\n\n\n\n\n\n","category":"function"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" Z","category":"page"},{"location":"chp/#Juqst.Z","page":"CHP/Tableau Commands","title":"Juqst.Z","text":"Z(t::Tableau,qubit::Integer,showOutput::Bool=false)\n\nConvenience function to perform a 'Z' gate on the tableau. Performs two phase gates.\n\nSee also: cnot, hadamard, measure, X, phase\n\n\n\n\n\nZ(t::Tableau,qubits::Integer...;showOutput::Bool = false)\n\nConvenience function to perform a 'Z' gate on the tableau on each of the qubits supplied. Performs the gate by doing two phase gates.\n\nExamples\n\njulia> Z(t,2,3,1)\n\nSee also: cnot hadamard, measure, X, Z\n\n\n\n\n\n","category":"function"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" measure","category":"page"},{"location":"chp/#Juqst.measure","page":"CHP/Tableau Commands","title":"Juqst.measure","text":"measure(t::Tableau,qubit::Integer)\n\nPerforms a measurement on the supplied qubit. If the Tableau is not in a Z eigenstate, it will (pseudo) randomly choose the result and collapse the Tableau approriately.\n\n\n\n\n\nmeasure(t::Tableau,qubits::Integer...;showOutput = false)\n\nPerforms a measurement on the supplied qubits. Results are reproted in a dictionary of outcomes.\n\nExamples\n\njulia> using Main.CHP\n\njulia> t = Tableau(4)\n\n+XIII\n+IXII\n+IIXI\n+IIIX\n-----\n+ZIII\n+IZII\n+IIZI\n+IIIZ\n\n\njulia> measure(t,1,2)\nDict{Any,Any}(2=>0,1=>0)\njulia>\n\n\n\n\n\nHelper function   Pass in the state, the noise (superOperator) and the measurements - use allZs to generate)   returns the mapped function.\n\n\n\n\n\n","category":"function"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" kets","category":"page"},{"location":"chp/#Juqst.kets","page":"CHP/Tableau Commands","title":"Juqst.kets","text":"kets(tableau::Tableau)\n\nreturns a string showing the kets of the state stabilised by the tableau.\n\n\n\n\n\n","category":"function"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" initialise","category":"page"},{"location":"chp/#Juqst.initialise","page":"CHP/Tableau Commands","title":"Juqst.initialise","text":"initialise(t::Tableau)\n\nInitialises the Tableau, setting it support the |000000> state. However, unlike reinitialse it does not change the commands associated with the Tableau.\n\nSee also: reinitialise\n\n\n\n\n\n","category":"function"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" reinitialise","category":"page"},{"location":"chp/#Juqst.reinitialise","page":"CHP/Tableau Commands","title":"Juqst.reinitialise","text":"reinitialise(t::Tableau)\n\nReinitialise the Tableau, setting it support the |000000> state. Resets all commands associated with the Tableau.\n\nSee also: initialise\n\n\n\n\n\n","category":"function"},{"location":"chp/#Tableaus-and-Cliffords-1","page":"CHP/Tableau Commands","title":"Tableaus and Cliffords","text":"","category":"section"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" cliffordToTableau","category":"page"},{"location":"chp/#Juqst.cliffordToTableau","page":"CHP/Tableau Commands","title":"Juqst.cliffordToTableau","text":"cliffordToTableau(qubits,clifford,signs)\n\nConverts an integer into a Clifford. You need to specify the number of qubits in the tableau, the clifford number and the bit signs corresponding to the rows of the Tableau. The commands used to create the Clifford can be found in Tableau.commands and Tableau.executeCommands.? It is fine to specify numbers that are too large (they wrap), but the helper functions\n\ngetNumberOfSymplecticCliffords(n::BigInt)::BigInt\ngetNumberOfBitStringsCliffords(n)\n\nWill show how many cliffords there are for a certain number of qubits (Warning this is a very large number for n > 2)\n\n\n\n\n\n","category":"function"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" tableauToClifford","category":"page"},{"location":"chp/#Juqst.tableauToClifford","page":"CHP/Tableau Commands","title":"Juqst.tableauToClifford","text":"tableauToClifford(t::Tableau)\n\nReturns the 'symplectic' number that corresponds to the clifford embedded in the Tableau. Note that this is modulo the bit signs. I.e. the tableaus corresponding to e.g. cliffordToTableau(1,3,3) and cliffordToTableau(1,3,4) will both return 3.\n\n\n\n\n\n","category":"function"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" decomposeState","category":"page"},{"location":"chp/#Juqst.decomposeState","page":"CHP/Tableau Commands","title":"Juqst.decomposeState","text":"decomposeState(tableau::Tableau,rationalise=true)\n\nDecomposes the state stabilised by the Tableau using the Aaronsen/Gottesman method\n\nThat is it will decompose the \"arbitrary\" state into a series of CHP (cnot, hadamard and phase) gates. This is unlikely to be the most concise decomposition. Unless rationalise is set to false there will be some naive trimming of gates, basically self eliminating gates (e.g. 4 phase gates) are removed. The commands (and the execCommands) in the tableau are wiped and recreated. Following the decomposition the state is re-created using the new commands.\n\n\n\n\n\n","category":"function"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" getNumberOfCliffords","category":"page"},{"location":"chp/#Juqst.getNumberOfCliffords","page":"CHP/Tableau Commands","title":"Juqst.getNumberOfCliffords","text":"getNumberOfCliffords(n::Integer)::BigInt\n\nreturns the number of Cliffords for n qubits.\n\n\n\n\n\n","category":"function"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" getNumberOfSymplecticCliffords","category":"page"},{"location":"chp/#Juqst.getNumberOfSymplecticCliffords","page":"CHP/Tableau Commands","title":"Juqst.getNumberOfSymplecticCliffords","text":"getNumberOfSymplecticCliffords(n::Integer)::BigInt\n\nreturns the number of Cliffords for n qubits, modulo the signs on each row of the tableau. Note\n\ngetNumberOfCliffords(n) == getNumberOfSymplecticCliffords(n)*getNumerOfBitStringsCliffords(n)\n\n\n\n\n\n","category":"function"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" getNumberOfBitStringsCliffords","category":"page"},{"location":"chp/#Juqst.getNumberOfBitStringsCliffords","page":"CHP/Tableau Commands","title":"Juqst.getNumberOfBitStringsCliffords","text":"getNumberOfBitStringsCliffords(n)\n\nreturns the number of bitstrings representing a +/- on each row for the Tableau. Note:\n\ngetNumberOfCliffords(n) == getNumberOfSymplecticCliffords(n)*getNumerOfBitStringsCliffords(n)\n\n\n\n\n\n","category":"function"},{"location":"chp/#Generating-Clifford-matrices-1","page":"CHP/Tableau Commands","title":"Generating Clifford matrices","text":"","category":"section"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" generateRawCliffords","category":"page"},{"location":"chp/#Juqst.generateRawCliffords","page":"CHP/Tableau Commands","title":"Juqst.generateRawCliffords","text":"generateRawCliffords(;phaseGate=[1 0;0 im],hadmardGate=1/sqrt(2)*[1 1;1 -1])::Array{Complex{Float64},2}[]\n\nreturns the single qubit cliffords, generated using the passed in  phase and hadamard gates (perfect gates default)\n\n\n\n\n\n","category":"function"},{"location":"chp/#","page":"CHP/Tableau Commands","title":"CHP/Tableau Commands","text":" makeFromCommand","category":"page"},{"location":"chp/#Juqst.makeFromCommand","page":"CHP/Tableau Commands","title":"Juqst.makeFromCommand","text":"makeFromCommand(command)\n\nTakes the commands in a Tableau and uses them to build a matrix representing the Tableau (in the computational basis)\nUses the original initialise command to determine the size of the system.\nNote: for many qubits this gets quite big (scales as $2^n$)\n\n\n\n\n\nmakeFromCommand(t::Tableau)\n\nUses the commands stored in a Tableau and uses them to build a matrix representing the Tableau (in the computational basis)\nUses the original initialise command to determine the size of the system.\nNote: for many qubits this gets quite big (scales as $2^n$)\n\n\n\n\n\n","category":"function"},{"location":"channels/#Random-Channels-1","page":"Random Channels","title":"Random Channels","text":"","category":"section"},{"location":"channels/#Measurements-1","page":"Random Channels","title":"Measurements","text":"","category":"section"},{"location":"channels/#","page":"Random Channels","title":"Random Channels","text":" fidelity","category":"page"},{"location":"channels/#Juqst.fidelity","page":"Random Channels","title":"Juqst.fidelity","text":"returns the fidelity of the channel (in PauliLiouville basis)\n\n\n\n\n\n","category":"function"},{"location":"channels/#","page":"Random Channels","title":"Random Channels","text":" unitarity","category":"page"},{"location":"channels/#Juqst.unitarity","page":"Random Channels","title":"Juqst.unitarity","text":"returns the unitarity of the channel (PauliLiouville basis)\n\n\n\n\n\n","category":"function"},{"location":"channels/#","page":"Random Channels","title":"Random Channels","text":" unitarityPercent","category":"page"},{"location":"channels/#Juqst.unitarityPercent","page":"Random Channels","title":"Juqst.unitarityPercent","text":"A given fidelity has a minimum unitarity that it can have\n(so perfect fidelity = 1 = unitarity)\nThis shows as a percentage how much the unitarity of the channel\nlies between the minimum and the maximum (always 1)\n\n\n\n\n\n","category":"function"},{"location":"channels/#Creation-1","page":"Random Channels","title":"Creation","text":"","category":"section"},{"location":"channels/#","page":"Random Channels","title":"Random Channels","text":" genChannel","category":"page"},{"location":"channels/#Juqst.genChannel","page":"Random Channels","title":"Juqst.genChannel","text":"genChannel(r1,sm,sv,r2)\nRotate the sigma channel randomly to generate an arbitrary channel\nr1 represents a rotation. The elements of a vector of three normally distributed elements are multiplied by this and used as an XZX rotation. For high fidelity channels this will be small.\nsm, represents the diagonal channel. This is the mean. High fidelity channels will have this close to 1.\nsv, represents the variance in the diagonal channel.\nr2, like r1.\n\nFor example randomFidelityNoise is defined as   genChannel(0.06,0.998,0.04,0.06)\nwhereas the noisier randomMeasureNoise is       genChannel(0.05,0.98,0.15,0.05)\n\n\n\n\n\n","category":"function"},{"location":"channels/#","page":"Random Channels","title":"Random Channels","text":" randomFidelityNoise","category":"page"},{"location":"channels/#Juqst.randomFidelityNoise","page":"Random Channels","title":"Juqst.randomFidelityNoise","text":"Helper function to generate typical, high fidelity channel.\n\n\n\n\n\n","category":"function"},{"location":"channels/#","page":"Random Channels","title":"Random Channels","text":" randomPrepNoise","category":"page"},{"location":"channels/#Juqst.randomPrepNoise","page":"Random Channels","title":"Juqst.randomPrepNoise","text":"Helper function to generate typical, lower fidelity channel.\nI use it to simulate a state preparation channel.\n\n\n\n\n\n","category":"function"},{"location":"channels/#","page":"Random Channels","title":"Random Channels","text":" randomMeasureNoise","category":"page"},{"location":"channels/#Juqst.randomMeasureNoise","page":"Random Channels","title":"Juqst.randomMeasureNoise","text":"Helper function to generate typical, lower fidelity channel.\nI typically use it to simulate measurement error.\n\n\n\n\n\n","category":"function"},{"location":"channels/#","page":"Random Channels","title":"Random Channels","text":" genChannelMap","category":"page"},{"location":"channels/#Juqst.genChannelMap","page":"Random Channels","title":"Juqst.genChannelMap","text":"function genChannelMap(f)\nSimple helper function - designed to help generate a map of a specific fidelity (supplied parameter).\nJust generates random channels until you get one of the correct fidelity $\\pm 0.0001$.\nIn general though you would want to rewrite this to give genChannel\nparameters that will result in random channels that often bracket the desired fidelity\nMay take a long time if the parameters are far from the types of channels generated\nby randomFidelityNoise.\n\n\n\n\n\n","category":"function"},{"location":"#Juqst-Documentation-1","page":"Juqst Documentation","title":"Juqst Documentation","text":"","category":"section"},{"location":"#","page":"Juqst Documentation","title":"Juqst Documentation","text":"Pages = [\"chp.md\", \"open-systems.md\",\"channels.md\"]\nDepth = 3","category":"page"},{"location":"#","page":"Juqst Documentation","title":"Juqst Documentation","text":"This is some software that brings together:","category":"page"},{"location":"#","page":"Juqst Documentation","title":"Juqst Documentation","text":"a simulation of stabiliser circuits Aaronson/Gottesman arXiv:quant-ph/0406196\ncode to select an arbitrary Clifford group element Koenig/Smolin arXiv:quant-ph/1406.2170\ndecomposition an arbitrary clifford unitary into a quantum circuit consistiting of hadamard, phase and two-qubit cnot gates.Aaronson/Gottesman arXiv:quant-ph/0406196\nconversion of the Tableau to a unitary matrix\nA slightly modified version of Marcus da Silva's QuantumInfo.jl - updated with some minor modifications and additions.\nSome additional functionality to allow the creation of random quantum channels (for testing purposes).","category":"page"},{"location":"open-systems/#Channel-Conversions-1","page":"Channel Conversions","title":"Channel Conversions","text":"","category":"section"},{"location":"open-systems/#Conversion-1","page":"Channel Conversions","title":"Conversion","text":"","category":"section"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" choi2liou","category":"page"},{"location":"open-systems/#Juqst.choi2liou","page":"Channel Conversions","title":"Juqst.choi2liou","text":"choi2liou\n\nTakes a superoperator in choi matrix form and returns the liouville superoperator (computational basis)\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" choi2kraus","category":"page"},{"location":"open-systems/#Juqst.choi2kraus","page":"Channel Conversions","title":"Juqst.choi2kraus","text":"takes the choi matrix and returns the kraus operators.    This stays the same, save that we need to take into account dimensional factors.    Note slight negative eigenvalue (rounding can cause problems). Here I round to 15 digits.\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" choiX2liou","category":"page"},{"location":"open-systems/#Juqst.choiX2liou","page":"Channel Conversions","title":"Juqst.choiX2liou","text":"takes the Chi matrix (Choi matrix in Pauli basis) and return the liouville superoperator, computaitonal basis\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" choi2chi","category":"page"},{"location":"open-systems/#Juqst.choi2chi","page":"Channel Conversions","title":"Juqst.choi2chi","text":"Takes a choi matrix and returns the Chi Matrix    Note the basis here has changed from marcusps version,  The rightmost paulis are varying the quickest.   Also note the transpose ( .' ) - this makes it ROW stacking   So for instance   (0 -im//im 0) vectorises as (0 -im im 0) (unlike column used elsewhere where its (0 im -im 0))\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" kraus2choi","category":"page"},{"location":"open-systems/#Juqst.kraus2choi","page":"Channel Conversions","title":"Juqst.kraus2choi","text":"Takes a vector of kraus operators and returns the choi matrix\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" kraus2liou","category":"page"},{"location":"open-systems/#Juqst.kraus2liou","page":"Channel Conversions","title":"Juqst.kraus2liou","text":"Takes a vector of kraus operators (matrices) and    converts them to a liouville superoperator (computational basis)\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":"liou2choi","category":"page"},{"location":"open-systems/#Juqst.liou2choi","page":"Channel Conversions","title":"Juqst.liou2choi","text":"liou2choi\n\nTake a liouville superoperator (computational basis) and return the choi matrix\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" liou2choiX","category":"page"},{"location":"open-systems/#Juqst.liou2choiX","page":"Channel Conversions","title":"Juqst.liou2choiX","text":"takes a liouville superoperator (computational basis) and returns the Chi matrix   (basically the choi matrix in Pauli basis)\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" liou2kraus","category":"page"},{"location":"open-systems/#Juqst.liou2kraus","page":"Channel Conversions","title":"Juqst.liou2kraus","text":"Takes a liouville superoperator (computational basis) and   returns a vector of the equivalen Krawu vectors\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" liou2pauliliou","category":"page"},{"location":"open-systems/#Juqst.liou2pauliliou","page":"Channel Conversions","title":"Juqst.liou2pauliliou","text":"Converts a liouville superoperator in the computaional basis   to one in the pauli basis. Order of Paulis is I,X,Y and Z.\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" pauliliou2liou","category":"page"},{"location":"open-systems/#Juqst.pauliliou2liou","page":"Channel Conversions","title":"Juqst.pauliliou2liou","text":"Converts a liouville superoperator in the Pauli basis   to one in the computational basis. Order of Paulis is I,X,Y and Z.\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#Manipulation-1","page":"Channel Conversions","title":"Manipulation","text":"","category":"section"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" makeSuper","category":"page"},{"location":"open-systems/#Juqst.makeSuper","page":"Channel Conversions","title":"Juqst.makeSuper","text":"function makeSuper(u)\n\nTakes an operator and turns into a superoperator. Pauli basis.\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" Juqst.getSuperVec","category":"page"},{"location":"open-systems/#Juqst.getSuperVec","page":"Channel Conversions","title":"Juqst.getSuperVec","text":"pass in a density matrix, gives you the super vector that corresponds to it\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#Verification-1","page":"Channel Conversions","title":"Verification","text":"","category":"section"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" istp","category":"page"},{"location":"open-systems/#Juqst.istp","page":"Channel Conversions","title":"Juqst.istp","text":"istp(m;tol)\n\nReturns whether is trace perserving..   Assumes input is in liouville basis (not pauli-liouville - use pauliliou2liou)\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" iscp","category":"page"},{"location":"open-systems/#Juqst.iscp","page":"Channel Conversions","title":"Juqst.iscp","text":"iscp(m;tol)\n\nReturns whether is completely positivel.   Assumes input is in liouville basis (not pauli-liouville - use pauliliou2liou)   Converts to choi and checks the eigenvalues.   – tweaked to increase eps slightly was getting a trivial false !cp right on the boundary.\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" ischannel","category":"page"},{"location":"open-systems/#Juqst.ischannel","page":"Channel Conversions","title":"Juqst.ischannel","text":"ischannel(m;tol)\n\nReturns whether is the liouville superoperator is trace perserving and completely positive.   Assumes input is in liouville basis (not pauli-liouville - use pauliliou2liou)\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" isunital","category":"page"},{"location":"open-systems/#Juqst.isunital","page":"Channel Conversions","title":"Juqst.isunital","text":"unital(m;tol)\n\nReturns whether is the liouville superoperator is unital.   Assumes input is in liouville basis (not pauli-liouville - use pauliliou2liou)\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#Helper-1","page":"Channel Conversions","title":"Helper","text":"","category":"section"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" Juqst.genLabels","category":"page"},{"location":"open-systems/#Juqst.genLabels","page":"Channel Conversions","title":"Juqst.genLabels","text":"Helper function for labeling graphs, pass in the qubits get the string of Is and Zs   e.g. with two you get [\"00\",\"01\",\"10\",\"11\"]\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" Juqst.measure(s,measureNoise,allZs)","category":"page"},{"location":"open-systems/#Juqst.measure-Tuple{Any,Any,Any}","page":"Channel Conversions","title":"Juqst.measure","text":"Helper function   Pass in the state, the noise (superOperator) and the measurements - use allZs to generate)   returns the mapped function.\n\n\n\n\n\n","category":"method"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" Juqst.genArrows","category":"page"},{"location":"open-systems/#Juqst.genArrows","page":"Channel Conversions","title":"Juqst.genArrows","text":"Helper function (chart axis)   return all the ups and downs for a certain number of qubits as a list of strings\n\n\n\n\n\n","category":"function"},{"location":"open-systems/#","page":"Channel Conversions","title":"Channel Conversions","text":" Juqst.genZs","category":"page"},{"location":"open-systems/#Juqst.genZs","page":"Channel Conversions","title":"Juqst.genZs","text":"returns an array of the 'measurement' operators that extract each of the z measurements   e.g. for two qubits will return the II, IZ, ZI and ZZ measurements\n\n\n\n\n\n","category":"function"}]
}
