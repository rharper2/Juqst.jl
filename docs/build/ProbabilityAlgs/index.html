<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Probability Distribution Commands · Juqst Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Juqst Documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Probability Distribution Commands</a><ul class="internal"><li><a class="tocitem" href="#Creating-and-manipulating-1"><span>Creating and manipulating</span></a></li></ul></li><li><a class="tocitem" href="../channels/">Random Channels</a></li><li><a class="tocitem" href="../chp/">CHP/Tableau Commands</a></li><li><a class="tocitem" href="../">Juqst Documentation</a></li><li><a class="tocitem" href="../open-systems/">Channel Conversions</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Probability Distribution Commands</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Probability Distribution Commands</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rharper2/Juqst.jl/blob/master/docs/src/ProbabilityAlgs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Probability-Distribution-Commands-1"><a class="docs-heading-anchor" href="#Probability-Distribution-Commands-1">Probability Distribution Commands</a><a class="docs-heading-anchor-permalink" href="#Probability-Distribution-Commands-1" title="Permalink"></a></h1><h2 id="Creating-and-manipulating-1"><a class="docs-heading-anchor" href="#Creating-and-manipulating-1">Creating and manipulating</a><a class="docs-heading-anchor-permalink" href="#Creating-and-manipulating-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Juqst.readInCSVFile" href="#Juqst.readInCSVFile"><code>Juqst.readInCSVFile</code></a> — <span class="docstring-category">Function</span></header><section><div><p>readInCSVFile(filename)</p><p><strong>Arguments</strong></p><pre><code class="language-none">Filename: full name of a csv delimited Filename</code></pre><p><strong>File Format</strong></p><pre><code class="language-none">Assumes that each sequence appears on a new line and each line has the same number of entries.
Assumes that it is a raw count for each of the possible measurement outcomes.
Note it is important to know the order of the outcomes (this is significant).
Although this can be overriden, it is a assumed that they are stored as:</code></pre><pre><code class="language-none">			00000000
			00000001
			00000010
			00000011
			
			...
			11111110
			11111111

		i.e. lsb to the right.</code></pre><p>Returns a full rows x col matrix depending on the number of entries of the file. for a 16 qubit machine, where the data was taken over 6 sequences we will return a 6x655536 array of Ints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L16-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.transformToFidelity" href="#Juqst.transformToFidelity"><code>Juqst.transformToFidelity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">transformToFidelity(data)</code></pre><p>##	Arguments: 	Data, as returned by readInCSVFile - see help for that function.</p><p><strong>Returns:</strong></p><pre><code class="language-none">The Hadamard transformed fidelities for each sequence as a list of lists.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L48-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.fitTheFidelities" href="#Juqst.fitTheFidelities"><code>Juqst.fitTheFidelities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fitTheFidelties(lengths, data; no =0)</code></pre><p><strong>Arguments</strong></p><p>-	<code>lengths: Array{Int64,1}</code>, e.g. collect(1:2:24) - the length at which each of the above sets of data was gathered.</p><ul><li><p><code>data: Array{Array{Float64,1},1}</code>, this is a list of observed probabilities at different sequences.</p></li><li><p><code>no:</code> printed with the warning message if we fail to fit. Allowing identification of problem in &quot;batch&quot; fits.</p></li></ul><p>Take the data, transform it  and see if we can fit it to an exponential decay. This proves problematic where the data is a bit sparse, as the decays can be all over the place. In general it is <em>extremely</em> helpful to have a 0 gate sequence as that helps to anchor the fits.</p><p>Here we check for convergence, and warn if it doesn&#39;t converge.</p><p>This enforces a cut-off to the data used for the fit. Specifically it gets rid of the &#39;tail&#39; of data.</p><p><strong>Returns</strong></p><pre><code class="language-none">three things:
-  the fitting parameters, 
-  the length of the sequence that was used for each parameter.
-  the indices of those that still failed to converge.</code></pre><p><strong>Typical usage</strong></p><pre><code class="language-none">	params,_ = fithTheFidelities(transformToFidelity(data),collect(1:2:22))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L66-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.projectSimplex" href="#Juqst.projectSimplex"><code>Juqst.projectSimplex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Projects the P&#39;s onto the simplex where they are all &gt;= 0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L137-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.convertAndProject" href="#Juqst.convertAndProject"><code>Juqst.convertAndProject</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Convert and project the fitted fidelities, to rerieve the &#39;p&#39;s representing the joint probabilities.

Input: The parameters that have been fit.
Output: The projected ps.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L156-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.marginalise" href="#Juqst.marginalise"><code>Juqst.marginalise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Returns the marginalised probability, given the (projected) probabilities in pps.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L184-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.gibbsRandomField" href="#Juqst.gibbsRandomField"><code>Juqst.gibbsRandomField</code></a> — <span class="docstring-category">Function</span></header><section><div><p>gibbsRandomField(pps,constraints)</p><p><strong>Arguments</strong></p><p>-	<code>pps: Array{Float64,1}</code> For example the output of convertAndProject -	<code>constraints: Array{Int64,1}</code>: The division of the gibbs field. See below for example.</p><pre><code class="language-none">Takes a joint probability and the gibbs variable constraints and returns a vector of reduced probability distributions.
For example the constraints might be [[1,2,3,4],[3,4,5,6],[5,6,7,8]] over a field of 8 qubits
This would return an array of 3 ϕ&#39;s each 16 long (2^4), from which the joint probability can be extracted on the assumption
That, say, qubits 1,2 are independent of qubits 5-8.
Note: the assumption inbuilt here is that the constraints end and start with qubits in common e.g. [1,2,-&gt;3,4],[3,4&lt;-,5,6]</code></pre><p>Note the other version of is one gibbsRandomField, where the constraints are constraints::Array{Array{Array{Any,1},1},1} is probably (now) preferred - there you can specify the constraints more generally. In particular as tuples of qubits and the qubits they are conditioned on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L224-L242">source</a></section><section><div><p>gibbsRandomField(pps,gen_constraints)</p><p><strong>Arguments</strong></p><ul><li><p><code>pps: Array{Float64,1}</code> For example the output of convertAndProject</p></li><li><p><code>constraints: Array{Array{Array{Any,1},1},1}</code>: The division of the gibbs field. See below for example.</p><p>Takes a joint probability and the variable constraints that are conditioned and returns a vector of reduced probability distributions.   It is up to the user to make sure that the factorization is complete and makes sense.   For example the constraints might be [[(1,2),(3,4)],[(3,),(4,5,6)],[(4,5,6,7,8),()]] over a field of 8 qubits   This would return an array of 3 ϕ&#39;s the first 16 long (2^4), the second 2^4 long and the third 2^5 long from which the joint probability can be extracted on the assumption   That, say, qubits 1,2 are independent of qubits 5-8.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L274-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.gibbsRandomField-Tuple{Any,Array{Array{Array{Any,1},1},1}}" href="#Juqst.gibbsRandomField-Tuple{Any,Array{Array{Array{Any,1},1},1}}"><code>Juqst.gibbsRandomField</code></a> — <span class="docstring-category">Method</span></header><section><div><p>gibbsRandomField(pps,gen_constraints)</p><p><strong>Arguments</strong></p><ul><li><p><code>pps: Array{Float64,1}</code> For example the output of convertAndProject</p></li><li><p><code>constraints: Array{Array{Array{Any,1},1},1}</code>: The division of the gibbs field. See below for example.</p><p>Takes a joint probability and the variable constraints that are conditioned and returns a vector of reduced probability distributions.   It is up to the user to make sure that the factorization is complete and makes sense.   For example the constraints might be [[(1,2),(3,4)],[(3,),(4,5,6)],[(4,5,6,7,8),()]] over a field of 8 qubits   This would return an array of 3 ϕ&#39;s the first 16 long (2^4), the second 2^4 long and the third 2^5 long from which the joint probability can be extracted on the assumption   That, say, qubits 1,2 are independent of qubits 5-8.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L274-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.getGrainedP-Tuple{Any,Any,Any}" href="#Juqst.getGrainedP-Tuple{Any,Any,Any}"><code>Juqst.getGrainedP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">For a given ϕ, the list of qubits we used to construct ϕ (graining) and the 
Bit pattern, the probability of which we want to extract</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L346-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.mutualInformation-Tuple{Any,Any,Any}" href="#Juqst.mutualInformation-Tuple{Any,Any,Any}"><code>Juqst.mutualInformation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function mutualInformation(p1,p2,p)

Returns the mutualInformation between probabilities at p1, p2 given probability distribution p.
Makes use of the marginalise function to marginalise over probabilities

$MI(p1,p2) =\sum\limit_{x\in p1,y\in p2}\left[p(x,y)\log{\frac{p(x,y)}{p(x),p(y)})\right]$


Some gotchas:
    I return -1 if p1==p2 , this allows an identification of the qubit where I loop.
    if p(x,y) is 0, p(x) or p(y) is 0 then this is defined as a &#39;zero&#39; part of the sum - even though the log is undefined.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L356-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.relativeEntropy-Tuple{Any,Any}" href="#Juqst.relativeEntropy-Tuple{Any,Any}"><code>Juqst.relativeEntropy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">relativeEntropy(P, Q)

Calculates the relative entropy between two joint probability distributions.
D(P||Q) = Sum p_j*log(p_j/q_j)

Undefined if any of the q_js are zero, unless the corresponding p_j is zero.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L396-L403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.JSD-Tuple{Any,Any}" href="#Juqst.JSD-Tuple{Any,Any}"><code>Juqst.JSD</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Jensen-Shannon Divergence - symmetric</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L419-L421">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.reconstructedJS-Tuple{Any,Any}" href="#Juqst.reconstructedJS-Tuple{Any,Any}"><code>Juqst.reconstructedJS</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Given a distribution and a set of constraints.
Reconstruct the distribution using the constraints.
Then return the JSD of the reconstructed distribution and the original distribution.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L427-L431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.reconstruct-Tuple{Any,Any}" href="#Juqst.reconstruct-Tuple{Any,Any}"><code>Juqst.reconstruct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Given a distribution and a set of constraints.
Return the reconstruction of a distribution parameterized by the constraints.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L436-L439">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.conditionalMutualInfo-NTuple{4,Any}" href="#Juqst.conditionalMutualInfo-NTuple{4,Any}"><code>Juqst.conditionalMutualInfo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Gives the conditional mutual information for the qubits 
supplied in X,Y and Z where we want I(XY|Z)

I(XY|Z) = Sum( P(x,y,z)log2( P(Z)P(X,Y,Z)/P(X,Z)P(Y,Z) )


All the heavy lifting is in getSummand.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L478-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.covarianceMatrix" href="#Juqst.covarianceMatrix"><code>Juqst.covarianceMatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">covarianceMatrix(p)</code></pre><p><strong>Covariance</strong></p><pre><code class="language-none">We can compute the covariance matrix between the 0/1 random variables representing no error / error. 
If x is a column vector of bits representing an error pattern, then we can compute the matrix
Expect_p[(x-μ) (x-μ)^T]
where μ = Expect_p[x]. 

If we set reverse to true, then we reverse the digits.
The way IBM stores its digits we wouldn&#39;t normally want to reverse them, but in general
this might not be true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L503-L515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.marginaliseFromRawData" href="#Juqst.marginaliseFromRawData"><code>Juqst.marginaliseFromRawData</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">marginaliseFromRawData

rawData - all of the observations ie. an array of 1..|lengths] each being a $2^n$ vector.
constraints - currently a list of constraints in the same from as [`gibbsRandomField(pps,constraints)`][@ref]
lengths - the lengths the data sets were taken at

Takes in the raw observations, for each of the lengths specified in length.
Extracts the joint probabilities needed from constraints.
Marginalises the observations, transforms, fits, transforms and fills in the joint probabilities.
Returns the completed gibbs factors.

Note if your $2^n$  vectors are too big, simply re-write to pass in the actual observations and work out the marginalised observations as you scan through them,
potentially sparse arrays will help (although not sure if marginalise will work)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L533-L548">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.correlationMatrix" href="#Juqst.correlationMatrix"><code>Juqst.correlationMatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">correlationMatrix(p)</code></pre><p><strong>Correlation</strong></p><pre><code class="language-none">Computes the covariance matrix $\Sigma$ and then let:
$D = \sqrt{diag{\Sigma}$

Return $D^{-1}\Sigma D^{-1}$
See also See also: [`covarianceMatrix`](@ref)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/rharper2/Juqst.jl/blob/a7cf6d493d9e3494b490a3941f0d6a96c5ad55e9/src/marginal.jl#L587-L597">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="../channels/">Random Channels »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 11 February 2020 17:43">Tuesday 11 February 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
