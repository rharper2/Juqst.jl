<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CHP/Tableau Commands · Juqst Documentation</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Juqst Documentation</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Juqst Documentation</a></li><li><a class="tocitem" href="../probability-algs/">Probability Distribution Commands</a></li><li class="is-active"><a class="tocitem" href>CHP/Tableau Commands</a><ul class="internal"><li><a class="tocitem" href="#Creating-and-manipulating"><span>Creating and manipulating</span></a></li><li><a class="tocitem" href="#Tableaus-and-Cliffords"><span>Tableaus and Cliffords</span></a></li><li><a class="tocitem" href="#Generating-Clifford-matrices"><span>Generating Clifford matrices</span></a></li></ul></li><li><a class="tocitem" href="../open-systems/">Channel Conversions</a></li><li><a class="tocitem" href="../channels/">Random Channels</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>CHP/Tableau Commands</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CHP/Tableau Commands</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rharper2/Juqst.jl/blob/master/docs/src/chp.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CHP/Tableau-Commands"><a class="docs-heading-anchor" href="#CHP/Tableau-Commands">CHP/Tableau Commands</a><a id="CHP/Tableau-Commands-1"></a><a class="docs-heading-anchor-permalink" href="#CHP/Tableau-Commands" title="Permalink"></a></h1><h2 id="Creating-and-manipulating"><a class="docs-heading-anchor" href="#Creating-and-manipulating">Creating and manipulating</a><a id="Creating-and-manipulating-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-and-manipulating" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Juqst.Tableau-Tuple{Integer}" href="#Juqst.Tableau-Tuple{Integer}"><code>Juqst.Tableau</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Tableau(n::Integer)</code></pre><p>sets up and returns the a CHP Tableau for n qubits.</p><p>This is based on the formalism given by:  <em>Improved Simulation of Stabilizer Circuits</em>,  Scott Aaronson and Daniel Gottesman,  arXiv:quant-ph/0406196v5</p><p>The initial tableau represents a |00...0<span>$\rangle$</span> ket in the stabiliser state  This stabilises with &quot;Z&quot; and anti-stabilises with &quot;X&quot;  So the tableau starts off with an Identity in the &#39;anti commute&#39; top half in the X section   and identity in the commuting (bottom) half in the Z section.</p><p>For the purposes of this port, the tableau is exactly replicated as per the paper  i.e. the &quot;state&quot; (Tableau.state) is an Int32 array (used as a bit array)  containing the following information.</p><pre><code class="nohighlight hljs"> x11   .....  x1n | z11   ...      z1n | r1
  .    \       .  |  .    \          . |  .
  .     \      .  |  .     \         . |  .     Destabilisers
  .      \     .  |  .      \        . |  .
 xn1      \   xnn | zn1      \      znn| rn
 ______________________________________________
 x(n+1)1. x(n+1)n | z(n+1) ... z(n+1)n | r(n+1)
  .    \       .  |  .      \        . |  .
  .     \      .  |  .       \       . |  .     Stabilisers
  .      \     .  |  .        \      . |  .
 x(2n)1   \x(2n)n | z(2n)1     \ z(2n)n| r(2n)</code></pre><p>Set Tableau.showRaw to true to see the underlying state as a matrix.</p><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a>, <a href="#Juqst.hadamard"><code>hadamard</code></a>, <a href="#Juqst.phase"><code>phase</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.X"><code>X</code></a>, <a href="#Juqst.Z"><code>Z</code></a></p><p>Related: <a href="#Juqst.cliffordToTableau"><code>cliffordToTableau</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.hadamard" href="#Juqst.hadamard"><code>Juqst.hadamard</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hadamard(t::Tableau,qubit::Integer,showOutput::Bool=false)</code></pre><p>Performs a hadamard gate on the specified qubit of the tableau.</p><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a>, <a href="#Juqst.phase"><code>phase</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.X"><code>X</code></a>, <a href="#Juqst.Z"><code>Z</code></a></p></div></section><section><div><pre><code class="nohighlight hljs">hadamard(t::Tableau,qubits::Integer...;showOutput::Bool = false)</code></pre><p>Peforms hadamards on <strong>each</strong> of the qubits supplied.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; hadamard(t,2,3,1)</code></pre><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a> <a href="#Juqst.phase"><code>phase</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.X"><code>X</code></a>, <a href="#Juqst.Z"><code>Z</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.phase" href="#Juqst.phase"><code>Juqst.phase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">phase(t::Tableau,qubit::Integer,showOutput::Bool=false)</code></pre><p>Performs a phase gate on the specified qubit of the tableau.</p><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a>, <a href="#Juqst.hadamard"><code>hadamard</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.X"><code>X</code></a>, <a href="#Juqst.Z"><code>Z</code></a></p></div></section><section><div><pre><code class="nohighlight hljs">phase(t::Tableau,qubits::Integer...;showOutput::Bool = false)</code></pre><p>Peforms phase on each of the qubits supplied.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; phase(t,2,3,1)</code></pre><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a> <a href="#Juqst.hadamard"><code>hadamard</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.X"><code>X</code></a>, <a href="#Juqst.Z"><code>Z</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.cnot" href="#Juqst.cnot"><code>Juqst.cnot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cnot(t::Tableau,control::Integer,target::Integer,showOutput=false)</code></pre><p>Performs a CNOT (controlled not) on the tableau, with the specified qubits as control and target.</p><p>If showOutput is passed as true the state of the tableau subsequent to the cnot is printed.</p><p>See also: <a href="#Juqst.hadamard"><code>hadamard</code></a>, <a href="#Juqst.phase"><code>phase</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.X"><code>X</code></a>, <a href="#Juqst.Z"><code>Z</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.X" href="#Juqst.X"><code>Juqst.X</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">X(t::Tableau,qubit::Integer,showOutput::Bool=false)</code></pre><p>Convenience function to perform an &#39;X&#39; gate on the tableau. Performs hadamard, two phase gates and a hadamard.</p><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a>, <a href="#Juqst.hadamard"><code>hadamard</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.Z"><code>Z</code></a>, <a href="#Juqst.phase"><code>phase</code></a></p></div></section><section><div><pre><code class="nohighlight hljs">X(t::Tableau,qubits::Integer...;showOutput::Bool = false)</code></pre><p>Convenience function to perform an &#39;X&#39; gate on the tableau on each of the qubits supplied. Performs the gate by doing a hadamard, two phase gates and a hadamard on each of the qubits.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; X(t,2,3,1)</code></pre><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a> <a href="#Juqst.hadamard"><code>hadamard</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.phase"><code>phase</code></a>, <a href="#Juqst.Z"><code>Z</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.Z" href="#Juqst.Z"><code>Juqst.Z</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Z(t::Tableau,qubit::Integer,showOutput::Bool=false)</code></pre><p>Convenience function to perform a &#39;Z&#39; gate on the tableau. Performs two phase gates.</p><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a>, <a href="#Juqst.hadamard"><code>hadamard</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.X"><code>X</code></a>, <a href="#Juqst.phase"><code>phase</code></a></p></div></section><section><div><pre><code class="nohighlight hljs">Z(t::Tableau,qubits::Integer...;showOutput::Bool = false)</code></pre><p>Convenience function to perform a &#39;Z&#39; gate on the tableau on each of the qubits supplied. Performs the gate by doing two phase gates.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Z(t,2,3,1)</code></pre><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a> <a href="#Juqst.hadamard"><code>hadamard</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.X"><code>X</code></a>, <a href="#Juqst.Z"><code>Z</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.measure" href="#Juqst.measure"><code>Juqst.measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">measure(t::Tableau,qubit::Integer)</code></pre><p>Performs a measurement on the supplied qubit. If the Tableau is not in a Z eigenstate, it will (pseudo) randomly choose the result and collapse the Tableau approriately.</p></div></section><section><div><pre><code class="nohighlight hljs">measure(t::Tableau,qubits::Integer...;showOutput = false)</code></pre><p>Performs a measurement on the supplied qubits. Results are reported in a dictionary of outcomes.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Main.CHP

julia&gt; t = Tableau(4)

+XIII
+IXII
+IIXI
+IIIX
-----
+ZIII
+IZII
+IIZI
+IIIZ


julia&gt; measure(t,1,2)
Dict{Any,Any}(2=&gt;0,1=&gt;0)
julia&gt;</code></pre></div></section><section><div><pre><code class="language-julia hljs">measure(s,measureNoise, allZs)</code></pre><p>Helper function in open-systems.jl   Pass in the state, the noise (as a superOperator) and the measurements - use allZs to generate)   returns the mapped function (x-&gt;x&#39;<em>measureNoise</em>s,allZs)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.kets" href="#Juqst.kets"><code>Juqst.kets</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kets(tableau::Tableau)</code></pre><p>returns a string showing the kets of the state stabilised by the tableau.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.initialise" href="#Juqst.initialise"><code>Juqst.initialise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">initialise(t::Tableau)</code></pre><p>Initialises the Tableau, setting it support the |000000&gt; state. However, unlike reinitialse it does not change the commands associated with the Tableau.</p><p>See also: <a href="#Juqst.reinitialise"><code>reinitialise</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.reinitialise" href="#Juqst.reinitialise"><code>Juqst.reinitialise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reinitialise(t::Tableau)</code></pre><p>Reinitialise the Tableau, setting it support the |000000&gt; state. Resets all commands associated with the Tableau.</p><p>See also: <a href="#Juqst.initialise"><code>initialise</code></a></p></div></section></article><h2 id="Tableaus-and-Cliffords"><a class="docs-heading-anchor" href="#Tableaus-and-Cliffords">Tableaus and Cliffords</a><a id="Tableaus-and-Cliffords-1"></a><a class="docs-heading-anchor-permalink" href="#Tableaus-and-Cliffords" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Juqst.cliffordToTableau" href="#Juqst.cliffordToTableau"><code>Juqst.cliffordToTableau</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cliffordToTableau(qubits,clifford,signs)</code></pre><p>Converts an integer into a Clifford. You need to specify the number of qubits in the tableau, the clifford number and the bit signs corresponding to the rows of the Tableau. The commands used to create the Clifford can be found in Tableau.commands and Tableau.executeCommands.? It is fine to specify numbers that are too large (they wrap), but the helper functions</p><pre><code class="language-Julia hljs">getNumberOfSymplecticCliffords(n::BigInt)::BigInt
getNumberOfBitStringsCliffords(n)</code></pre><p>Will show how many cliffords there are for a certain number of qubits (Warning this is a very large number for n &gt; 2)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.tableauToClifford" href="#Juqst.tableauToClifford"><code>Juqst.tableauToClifford</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tableauToClifford(t::Tableau)</code></pre><p>Returns the &#39;symplectic&#39; number that corresponds to the clifford embedded in the Tableau. Note that this is modulo the bit signs. I.e. the tableaus corresponding to e.g. cliffordToTableau(1,3,3) and cliffordToTableau(1,3,4) will both return 3.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.decomposeState" href="#Juqst.decomposeState"><code>Juqst.decomposeState</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">decomposeState(tableau::Tableau,rationalise=true)</code></pre><p>Decomposes the state stabilised by the Tableau using the Aaronsen/Gottesman method</p><p>That is it will decompose the &quot;arbitrary&quot; state into a series of CHP (cnot, hadamard and phase) gates. This is unlikely to be the most concise decomposition. Unless rationalise is set to false there will be some naive trimming of gates, basically self eliminating gates (e.g. 4 phase gates) are removed. The commands (and the execCommands) in the tableau are wiped and recreated. Following the decomposition the state is re-created using the new commands.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.getNumberOfCliffords" href="#Juqst.getNumberOfCliffords"><code>Juqst.getNumberOfCliffords</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getNumberOfCliffords(n::Integer)::BigInt</code></pre><p>returns the number of Cliffords for n qubits.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.getNumberOfSymplecticCliffords" href="#Juqst.getNumberOfSymplecticCliffords"><code>Juqst.getNumberOfSymplecticCliffords</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getNumberOfSymplecticCliffords(n::Integer)::BigInt</code></pre><p>returns the number of Cliffords for n qubits, modulo the signs on each row of the tableau. Note</p><p>getNumberOfCliffords(n) == getNumberOfSymplecticCliffords(n)*getNumerOfBitStringsCliffords(n)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.getNumberOfBitStringsCliffords" href="#Juqst.getNumberOfBitStringsCliffords"><code>Juqst.getNumberOfBitStringsCliffords</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getNumberOfBitStringsCliffords(n)</code></pre><p>returns the number of bitstrings representing a +/- on each row for the Tableau. Note:</p><p>getNumberOfCliffords(n) == getNumberOfSymplecticCliffords(n)*getNumerOfBitStringsCliffords(n)</p></div></section></article><h2 id="Generating-Clifford-matrices"><a class="docs-heading-anchor" href="#Generating-Clifford-matrices">Generating Clifford matrices</a><a id="Generating-Clifford-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-Clifford-matrices" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Juqst.generateRawCliffords" href="#Juqst.generateRawCliffords"><code>Juqst.generateRawCliffords</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generateRawCliffords(;phaseGate=[1 0;0 im],hadmardGate=1/sqrt(2)*[1 1;1 -1])::Array{Complex{Float64},2}[]</code></pre><p>returns the single qubit cliffords, generated using the passed in  phase and hadamard gates (perfect gates default)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.makeFromCommand" href="#Juqst.makeFromCommand"><code>Juqst.makeFromCommand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">makeFromCommand(command)

Takes the commands in a Tableau and uses them to build a matrix representing the Tableau (in the computational basis)
Uses the original initialise command to determine the size of the system.
Note: for many qubits this gets quite big (scales as $2^n$)</code></pre></div></section><section><div><pre><code class="nohighlight hljs">makeFromCommand(t::Tableau)

Uses the commands stored in a Tableau and uses them to build a matrix representing the Tableau (in the computational basis)
Uses the original initialise command to determine the size of the system.
Note: for many qubits this gets quite big (scales as $2^n$)</code></pre></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../probability-algs/">« Probability Distribution Commands</a><a class="docs-footer-nextpage" href="../open-systems/">Channel Conversions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 13 July 2023 11:28">Thursday 13 July 2023</span>. Using Julia version 1.9.0-rc1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
