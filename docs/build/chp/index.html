<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>CHP/Tableau Commands · Juqst Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Juqst Documentation</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Juqst Documentation</a></li><li class="is-active"><a class="tocitem" href>CHP/Tableau Commands</a><ul class="internal"><li><a class="tocitem" href="#Creating-and-manipulating-1"><span>Creating and manipulating</span></a></li><li><a class="tocitem" href="#Tableaus-and-Cliffords-1"><span>Tableaus and Cliffords</span></a></li><li><a class="tocitem" href="#Generating-Clifford-matrices-1"><span>Generating Clifford matrices</span></a></li></ul></li><li><a class="tocitem" href="../open-systems/">Channel Conversions</a></li><li><a class="tocitem" href="../channels/">Random Channels</a></li><li><a class="tocitem" href="../probability-algs/">Probability Distribution Commands</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>CHP/Tableau Commands</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>CHP/Tableau Commands</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rharper2/Juqst.jl/blob/master/docs/src/chp.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CHP/Tableau-Commands-1"><a class="docs-heading-anchor" href="#CHP/Tableau-Commands-1">CHP/Tableau Commands</a><a class="docs-heading-anchor-permalink" href="#CHP/Tableau-Commands-1" title="Permalink"></a></h1><h2 id="Creating-and-manipulating-1"><a class="docs-heading-anchor" href="#Creating-and-manipulating-1">Creating and manipulating</a><a class="docs-heading-anchor-permalink" href="#Creating-and-manipulating-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Juqst.Tableau-Tuple{Integer}" href="#Juqst.Tableau-Tuple{Integer}"><code>Juqst.Tableau</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Tableau(n::Integer)</code></pre><p>sets up and returns the a CHP Tableau for n qubits.</p><p>This is based on the formalism given by:  <em>Improved Simulation of Stabilizer Circuits</em>,  Scott Aaronson and Daniel Gottesman,  arXiv:quant-ph/0406196v5</p><p>The initial tableau represents a |00...0<span>$\rangle$</span> ket in the stabiliser state  This stabilises with &quot;Z&quot; and anti-stabilises with &quot;X&quot;  So the tableau starts off with an Identity in the &#39;anti commute&#39; top half in the X section   and identity in the commuting (bottom) half in the Z section.</p><p>For the purposes of this port, the tableau is exactly replicated as per the paper  i.e. the &quot;state&quot; (Tableau.state) is an Int32 array (used as a bit array)  containing the following information.</p><pre><code class="language-none"> x11   .....  x1n | z11   ...      z1n | r1
  .    \       .  |  .    \          . |  .
  .     \      .  |  .     \         . |  .     Destabilisers
  .      \     .  |  .      \        . |  .
 xn1      \   xnn | zn1      \      znn| rn
 ______________________________________________
 x(n+1)1. x(n+1)n | z(n+1) ... z(n+1)n | r(n+1)
  .    \       .  |  .      \        . |  .
  .     \      .  |  .       \       . |  .     Stabilisers
  .      \     .  |  .        \      . |  .
 x(2n)1   \x(2n)n | z(2n)1     \ z(2n)n| r(2n)</code></pre><p>Set Tableau.showRaw to true to see the underlying state as a matrix.</p><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a>, <a href="#Juqst.hadamard"><code>hadamard</code></a>, <a href="#Juqst.phase"><code>phase</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.X"><code>X</code></a>, <a href="#Juqst.Z"><code>Z</code></a></p><p>Related: <a href="#Juqst.cliffordToTableau"><code>cliffordToTableau</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.hadamard" href="#Juqst.hadamard"><code>Juqst.hadamard</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hadamard(t::Tableau,qubit::Integer,showOutput::Bool=false)</code></pre><p>Performs a hadamard gate on the specified qubit of the tableau.</p><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a>, <a href="#Juqst.phase"><code>phase</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.X"><code>X</code></a>, <a href="#Juqst.Z"><code>Z</code></a></p></div></section><section><div><pre><code class="language-none">hadamard(t::Tableau,qubits::Integer...;showOutput::Bool = false)</code></pre><p>Peforms hadamards on <strong>each</strong> of the qubits supplied.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; hadamard(t,2,3,1)</code></pre><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a> <a href="#Juqst.phase"><code>phase</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.X"><code>X</code></a>, <a href="#Juqst.Z"><code>Z</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.phase" href="#Juqst.phase"><code>Juqst.phase</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">phase(t::Tableau,qubit::Integer,showOutput::Bool=false)</code></pre><p>Performs a phase gate on the specified qubit of the tableau.</p><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a>, <a href="#Juqst.hadamard"><code>hadamard</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.X"><code>X</code></a>, <a href="#Juqst.Z"><code>Z</code></a></p></div></section><section><div><pre><code class="language-none">phase(t::Tableau,qubits::Integer...;showOutput::Bool = false)</code></pre><p>Peforms phase on each of the qubits supplied.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; phase(t,2,3,1)</code></pre><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a> <a href="#Juqst.hadamard"><code>hadamard</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.X"><code>X</code></a>, <a href="#Juqst.Z"><code>Z</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.cnot" href="#Juqst.cnot"><code>Juqst.cnot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cnot(t::Tableau,control::Integer,target::Integer,showOutput=false)</code></pre><p>Performs a CNOT (controlled not) on the tableau, with the specified qubits as control and target.</p><p>If showOutput is passed as true the state of the tableau subsequent to the cnot is printed.</p><p>See also: <a href="#Juqst.hadamard"><code>hadamard</code></a>, <a href="#Juqst.phase"><code>phase</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.X"><code>X</code></a>, <a href="#Juqst.Z"><code>Z</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.X" href="#Juqst.X"><code>Juqst.X</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">X(t::Tableau,qubit::Integer,showOutput::Bool=false)</code></pre><p>Convenience function to perform an &#39;X&#39; gate on the tableau. Performs hadamard, two phase gates and a hadamard.</p><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a>, <a href="#Juqst.hadamard"><code>hadamard</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.Z"><code>Z</code></a>, <a href="#Juqst.phase"><code>phase</code></a></p></div></section><section><div><pre><code class="language-none">X(t::Tableau,qubits::Integer...;showOutput::Bool = false)</code></pre><p>Convenience function to perform an &#39;X&#39; gate on the tableau on each of the qubits supplied. Performs the gate by doing a hadamard, two phase gates and a hadamard on each of the qubits.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; X(t,2,3,1)</code></pre><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a> <a href="#Juqst.hadamard"><code>hadamard</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.phase"><code>phase</code></a>, <a href="#Juqst.Z"><code>Z</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.Z" href="#Juqst.Z"><code>Juqst.Z</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Z(t::Tableau,qubit::Integer,showOutput::Bool=false)</code></pre><p>Convenience function to perform a &#39;Z&#39; gate on the tableau. Performs two phase gates.</p><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a>, <a href="#Juqst.hadamard"><code>hadamard</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.X"><code>X</code></a>, <a href="#Juqst.phase"><code>phase</code></a></p></div></section><section><div><pre><code class="language-none">Z(t::Tableau,qubits::Integer...;showOutput::Bool = false)</code></pre><p>Convenience function to perform a &#39;Z&#39; gate on the tableau on each of the qubits supplied. Performs the gate by doing two phase gates.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; Z(t,2,3,1)</code></pre><p>See also: <a href="#Juqst.cnot"><code>cnot</code></a> <a href="#Juqst.hadamard"><code>hadamard</code></a>, <a href="#Juqst.measure"><code>measure</code></a>, <a href="#Juqst.X"><code>X</code></a>, <a href="#Juqst.Z"><code>Z</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.measure" href="#Juqst.measure"><code>Juqst.measure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">measure(t::Tableau,qubit::Integer)</code></pre><p>Performs a measurement on the supplied qubit. If the Tableau is not in a Z eigenstate, it will (pseudo) randomly choose the result and collapse the Tableau approriately.</p></div></section><section><div><pre><code class="language-none">measure(t::Tableau,qubits::Integer...;showOutput = false)</code></pre><p>Performs a measurement on the supplied qubits. Results are reproted in a dictionary of outcomes.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using Main.CHP

julia&gt; t = Tableau(4)

+XIII
+IXII
+IIXI
+IIIX
-----
+ZIII
+IZII
+IIZI
+IIIZ


julia&gt; measure(t,1,2)
Dict{Any,Any}(2=&gt;0,1=&gt;0)
julia&gt;</code></pre></div></section><section><div><p>Helper function   Pass in the state, the noise (superOperator) and the measurements - use allZs to generate)   returns the mapped function.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.kets" href="#Juqst.kets"><code>Juqst.kets</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kets(tableau::Tableau)</code></pre><p>returns a string showing the kets of the state stabilised by the tableau.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.initialise" href="#Juqst.initialise"><code>Juqst.initialise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">initialise(t::Tableau)</code></pre><p>Initialises the Tableau, setting it support the |000000&gt; state. However, unlike reinitialse it does not change the commands associated with the Tableau.</p><p>See also: <a href="#Juqst.reinitialise"><code>reinitialise</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.reinitialise" href="#Juqst.reinitialise"><code>Juqst.reinitialise</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reinitialise(t::Tableau)</code></pre><p>Reinitialise the Tableau, setting it support the |000000&gt; state. Resets all commands associated with the Tableau.</p><p>See also: <a href="#Juqst.initialise"><code>initialise</code></a></p></div></section></article><h2 id="Tableaus-and-Cliffords-1"><a class="docs-heading-anchor" href="#Tableaus-and-Cliffords-1">Tableaus and Cliffords</a><a class="docs-heading-anchor-permalink" href="#Tableaus-and-Cliffords-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Juqst.cliffordToTableau" href="#Juqst.cliffordToTableau"><code>Juqst.cliffordToTableau</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">cliffordToTableau(qubits,clifford,signs)</code></pre><p>Converts an integer into a Clifford. You need to specify the number of qubits in the tableau, the clifford number and the bit signs corresponding to the rows of the Tableau. The commands used to create the Clifford can be found in Tableau.commands and Tableau.executeCommands.? It is fine to specify numbers that are too large (they wrap), but the helper functions</p><pre><code class="language-Julia">getNumberOfSymplecticCliffords(n::BigInt)::BigInt
getNumberOfBitStringsCliffords(n)</code></pre><p>Will show how many cliffords there are for a certain number of qubits (Warning this is a very large number for n &gt; 2)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.tableauToClifford" href="#Juqst.tableauToClifford"><code>Juqst.tableauToClifford</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tableauToClifford(t::Tableau)</code></pre><p>Returns the &#39;symplectic&#39; number that corresponds to the clifford embedded in the Tableau. Note that this is modulo the bit signs. I.e. the tableaus corresponding to e.g. cliffordToTableau(1,3,3) and cliffordToTableau(1,3,4) will both return 3.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.decomposeState" href="#Juqst.decomposeState"><code>Juqst.decomposeState</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">decomposeState(tableau::Tableau,rationalise=true)</code></pre><p>Decomposes the state stabilised by the Tableau using the Aaronsen/Gottesman method</p><p>That is it will decompose the &quot;arbitrary&quot; state into a series of CHP (cnot, hadamard and phase) gates. This is unlikely to be the most concise decomposition. Unless rationalise is set to false there will be some naive trimming of gates, basically self eliminating gates (e.g. 4 phase gates) are removed. The commands (and the execCommands) in the tableau are wiped and recreated. Following the decomposition the state is re-created using the new commands.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.getNumberOfCliffords" href="#Juqst.getNumberOfCliffords"><code>Juqst.getNumberOfCliffords</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getNumberOfCliffords(n::Integer)::BigInt</code></pre><p>returns the number of Cliffords for n qubits.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.getNumberOfSymplecticCliffords" href="#Juqst.getNumberOfSymplecticCliffords"><code>Juqst.getNumberOfSymplecticCliffords</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getNumberOfSymplecticCliffords(n::Integer)::BigInt</code></pre><p>returns the number of Cliffords for n qubits, modulo the signs on each row of the tableau. Note</p><p>getNumberOfCliffords(n) == getNumberOfSymplecticCliffords(n)*getNumerOfBitStringsCliffords(n)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.getNumberOfBitStringsCliffords" href="#Juqst.getNumberOfBitStringsCliffords"><code>Juqst.getNumberOfBitStringsCliffords</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getNumberOfBitStringsCliffords(n)</code></pre><p>returns the number of bitstrings representing a +/- on each row for the Tableau. Note:</p><p>getNumberOfCliffords(n) == getNumberOfSymplecticCliffords(n)*getNumerOfBitStringsCliffords(n)</p></div></section></article><h2 id="Generating-Clifford-matrices-1"><a class="docs-heading-anchor" href="#Generating-Clifford-matrices-1">Generating Clifford matrices</a><a class="docs-heading-anchor-permalink" href="#Generating-Clifford-matrices-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Juqst.generateRawCliffords" href="#Juqst.generateRawCliffords"><code>Juqst.generateRawCliffords</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">generateRawCliffords(;phaseGate=[1 0;0 im],hadmardGate=1/sqrt(2)*[1 1;1 -1])::Array{Complex{Float64},2}[]</code></pre><p>returns the single qubit cliffords, generated using the passed in  phase and hadamard gates (perfect gates default)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqst.makeFromCommand" href="#Juqst.makeFromCommand"><code>Juqst.makeFromCommand</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">makeFromCommand(command)

Takes the commands in a Tableau and uses them to build a matrix representing the Tableau (in the computational basis)
Uses the original initialise command to determine the size of the system.
Note: for many qubits this gets quite big (scales as $2^n$)</code></pre></div></section><section><div><pre><code class="language-none">makeFromCommand(t::Tableau)

Uses the commands stored in a Tableau and uses them to build a matrix representing the Tableau (in the computational basis)
Uses the original initialise command to determine the size of the system.
Note: for many qubits this gets quite big (scales as $2^n$)</code></pre></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Juqst Documentation</a><a class="docs-footer-nextpage" href="../open-systems/">Channel Conversions »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 9 June 2020 09:38">Tuesday 9 June 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
